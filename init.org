#+property: header-args:emacs-lisp :tangle init.el :comments org

* Abstract

Trying literate programming with my emacs configuration. This is
inspired by http://alhassy.com/emacs.d/. Protesilaos
(https://protesilaos.com/) uses such a method as well. His
configuration (https://git.sr.ht/~protesilaos/dotfiles) is also a good
resource to learn about Emacs.

* Emacs Native Configurations

This part contains configurations about all Emacs native options and
built-in packages. This part does not depends on any third-party
packages.

** Garbage Collection Settings

Adjust garbage collection thresholds during startup, and restore it
after startup. It is said that this reduces the boot time, but I have
not seen any observable change.

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5)

  (defvar my/file-name-handler-alist file-name-handler-alist)
  (defvar my/vc-handled-backends vc-handled-backends)

  (setq file-name-handler-alist nil
        vc-handled-backends nil)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 1024 1024 128)
                    gc-cons-percentage 0.2
                    file-name-handler-alist my/file-name-handler-alist
                    vc-handled-backends my/vc-handled-backends)))
#+end_src

** Native Compilation

Native compilation tends to generate a lot of warnings, which
interrupts whatever work you are doing. Disabling them reduces
distraction.

#+begin_src emacs-lisp
  (when (native-comp-available-p)
    (setq native-comp-async-report-warnings-errors 'silent) ; Emacs 28 with native compilation
    (setq native-compile-prune-cache t)) ; Emacs 29
#+end_src

** COMMENT Package

I use package.el to manage almost all the packages I use, except those
are only available on github. package.el is flexible since it can
easily be configured to use a local repository or a mirror. This is
really helpful when your network environment is not good.

#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives
        '(
          ("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("nongnu" . "https://elpa.nongnu.org/nongnu/")
          ;; ("melpa-stable" . "https://stable.melpa.org/packages/")

          ;; use local repository
          ;; ("local-melpa" . "~/elpa-mirror-master/melpa/")
          ;; ("local-gnu" . "~/elpa-mirror-master/gnu/")
          ;; ("local-nongnu" . "~/elpa-mirror-master/nongnu/")

          ;; Use either 163 or tsinghua mirror repository when official melpa
          ;; is slow or shutdown.

          ;; ;; {{ Option 1: 163 mirror repository:
          ;; ("gnu" . "https://mirrors.163.com/elpa/gnu/")
          ;; ("melpa" . "https://mirrors.163.com/elpa/melpa/")
          ;; ("melpa-stable" . "https://mirrors.163.com/elpa/stable-melpa/")
          ;; ("nongnu" . "https://mirrors.163.com/elpa/nongnu/")
          ;; ;; }}

          ;; ;; {{ Option 2: tsinghua mirror repository
          ;; ;; @see https://mirror.tuna.tsinghua.edu.cn/help/elpa/ on usage:
          ;; ;; ("gnu"   . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
          ;; ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
          ;; ("melpa-stable" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/stable-melpa/")
          ;; }}

          ;; gitlab mirror
          ;; ("melpa" . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/melpa/")
          ;; ("org"   . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/org/")
          ;; ("gnu"   . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/gnu/")
          ))
  ;; (package-refresh-contents)
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

** Disable =package.el=

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq package-enable-at-startup nil)
#+end_src

** Who am I?

#+begin_src emacs-lisp
  (setq user-full-name "Chang Xiaoduan"
        user-mail-address "drcxd@sina.com")
#+end_src

** Custom File Location

It is good to place the custom file in =.emacs.d= directory. This way,
we have all the files related to Emacs in one single directory. Some
users do not like the idea of a custom file since Emacs' Custom writes
to it. However, I consider the custom file as a location that you can
add some machine-dependent settings. For example, you can specify the
location of a binary file. I find it helpful since I am using Emacs on
different computers and different OSes. Thus, keep a volatile and
local configuration file helps solve some specific issues.

#+begin_src emacs-lisp
  (setq custom-file (locate-user-emacs-file "custom.el"))
#+end_src

** Frame Settings

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html][Frame parameters]] can be used to control the appearance of Emacs
frame. We can use these parameters to hide menu bar, adjust frame's
position and width, etc..

#+begin_src emacs-lisp :tangle "early-init.el"
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** uniquify

When two buffers of the same name are opened, Emacs has to uniquify
them so you can distinguish between them.

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-ignore-buffers-re "^\\*")
#+end_src

** ibuffer

ibuffer is a buffer list all opened buffers in Emacs. You can use it
to manage these buffers just as you manage files in dired.

#+begin_src emacs-lisp
  ;; (with-eval-after-load 'ibuffer
  ;;   ;; Use human readable Size column instead of original one
  ;;   (define-ibuffer-column size-h
  ;;     (:name "Size" :inline t)
  ;;     (cond
  ;;      ((> (buffer-size) 1000000)
  ;;       (format "%7.1fM" (/ (buffer-size) 1000000.0)))
  ;;      ((> (buffer-size) 1000)
  ;;       (format "%7.1fk" (/ (buffer-size) 1000.0)))
  ;;      (t
  ;;       (format "%8d" (buffer-size)))))

  ;;   (setq ibuffer-expert t
  ;;         ibuffer-show-empty-filter-groups nil
  ;;         ibuffer-display-summary nil)

  ;;   (setq ibuffer-saved-filter-groups
  ;;         (quote (("default"
  ;;                  ("code" (or (mode . emacs-lisp-mode)
  ;;                              (mode . cperl-mode)
  ;;                              (mode . c-mode)
  ;;                              (mode . java-mode)
  ;;                              (mode . idl-mode)
  ;;                              (mode . web-mode)
  ;;                              (mode . lisp-mode)
  ;;                              (mode . js2-mode)
  ;;                              (mode . c++-mode)
  ;;                              (mode . lua-mode)
  ;;                              (mode . cmake-mode)
  ;;                              (mode . ruby-mode)
  ;;                              (mode . css-mode)
  ;;                              (mode . objc-mode)
  ;;                              (mode . sql-mode)
  ;;                              (mode . python-mode)
  ;;                              (mode . php-mode)
  ;;                              (mode . sh-mode)
  ;;                              (mode . json-mode)
  ;;                              (mode . scala-mode)
  ;;                              (mode . go-mode)
  ;;                              (mode . erlang-mode)))

  ;;                  ("dired" (or (mode . dired-mode)
  ;;                               (mode . sr-mode)))

  ;;                  ("erc" (mode . erc-mode))

  ;;                  ("planner" (or (name . "^\\*Calendar\\*$")
  ;;                                 (name . "^diary$")
  ;;                                 (mode . muse-mode)
  ;;                                 (mode . org-mode)
  ;;                                 (mode . org-agenda-mode)))

  ;;                  ("emacs" (or (name . "^\\*scratch\\*$")
  ;;                               (name . "^\\*Messages\\*$")))

  ;;                  ("gnus" (or (mode . message-mode)
  ;;                              (mode . bbdb-mode)
  ;;                              (mode . mail-mode)
  ;;                              (mode . gnus-group-mode)
  ;;                              (mode . gnus-summary-mode)
  ;;                              (mode . gnus-article-mode)
  ;;                              (name . "^\\.bbdb$")
  ;;                              (name . "^\\.newsrc-dribble")))))))
  ;;   (defun ibuffer-mode-hook-setup ()
  ;;     (unless (eq ibuffer-sorting-mode 'filename/process)
  ;;       (ibuffer-do-sort-by-filename/process))
  ;;     (ibuffer-switch-to-saved-filter-groups "default"))

  ;;   (add-hook 'ibuffer-mode-hook 'ibuffer-mode-hook-setup)

  ;;   ;; Modify the default ibuffer-formats
  ;;   (setq ibuffer-formats
  ;;         '((mark modified read-only " "
  ;;                 (name 18 18 :left :elide)
  ;;                 " "
  ;;                 (size-h 9 -1 :right)
  ;;                 " "
  ;;                 (mode 16 16 :left :elide)
  ;;                 " "
  ;;                 filename-and-process)))

  ;;   (setq ibuffer-filter-group-name-face 'font-lock-doc-face))

  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

** Fonts and Faces :dependency:

+ Sarasa Gothic font: https://github.com/be5invis/Sarasa-Gothic
+ Iosevka font: https://github.com/be5invis/Iosevka
+ Iosevka Comfy font: https://github.com/protesilaos/iosevka-comfy
+ Sarasa Term SC Nerd font: https://github.com/laishulu/Sarasa-Term-SC-Nerd

#+NAME: font-setup
#+begin_src emacs-lisp
  (set-fontset-font "fontset-default" 'han "Sarasa Gothic SC")

  (set-face-attribute 'default nil
                      :font "Iosevka Comfy"
                      :height 160)
  (set-face-attribute 'fixed-pitch nil
                      :font "Iosevka Comfy"
                      :height 1.0)
  (set-face-attribute 'variable-pitch nil
                      :font "Iosevka Comfy Duo"
                      :height 1.0)

  ;; italic
  (set-face-attribute 'italic nil
                      :slant 'italic
                      :underline nil)
#+end_src

** Mode Line

#+begin_src emacs-lisp
  (setq display-time-24hr-format t)
  (display-time)
  (column-number-mode)
#+end_src

** Auto Backup

By default, Emacs will automatically generate a backup file every time
you edit an existing file. If your file name is =fname.txt=, then it
generates a backup file named =fname.txt=. This can quickly make the
directory messy, so I prefer disable this feature.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
#+end_src

** Auto Save

Emacs can automatically save edited files after some certain idle
time. This feature is disabled by default. I would like to enable it
to prevent accidental loss of data. The idle time should not be too
short since this would incur frequently disk I/O.

Note: I found that changing the value of ~auto-save-visited-interval~
does not change the behavior of Emacs. This might be a
platform-specific bug.

#+begin_src emacs-lisp
  (auto-save-visited-mode 1)
  (setq auto-save-visited-interval 5)
#+end_src

** Auto Revert

I turn on auto-revert-mode because sometimes when a file is edited by
some external programs, edit it again and save it in Emacs will
conflict with the external changes. Enable auto-revert-mode eliminate
the chances of such problems.

#+begin_src emacs-lisp
  (global-auto-revert-mode)
  (setq auto-revert-verbose nil)
#+end_src

** Splash Screen

By default, Emacs shows a welcome screen every time it is
launched. This might be useful to new Emacs users, but for experienced
users, displaying the =*scratch*= buffer by default may be more
productive. You could also execute the command =about-emacs= to display
the splash screen manually.

#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
#+end_src

** No Tab Character

Tab could be translated to different length spaces by different
editors. To avoid such a difference, simply avoid using tab.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Recent Files

It would be convenient to quickly open the file you have edited in
your last Emacs session. With recentf-mode, you do not have to input
the location of the file every time you visit it, but choose from a
maintained recent file list.

#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src

** Dired

dired is the facility Emacs uses to manage files. It's the file
explorer of Emacs. You can perform many file operations in dired.

#+begin_src emacs-lisp
  (setq dired-kill-when-opening-new-dired-buffer t)
  (defun dired-mode-setup ()
    "Setup dired."
    ;; global-auto-revert-mode does not work for dired
    (auto-revert-mode)
    (setq dired-guess-shell-alist-user '(("\\.pdf\\'" "okular &"))))
  (add-hook 'dired-mode-hook 'dired-mode-setup)
  (with-eval-after-load 'dired
    (require 'dired-x))
#+end_src

** Mottoes

I would like the welcome message displayed in the scratch buffer be
some mottoes selected randomly from a pre-defined list.

#+begin_src emacs-lisp
  (defun my/process-raw-mottoes (lines)
    "Process motto strings so that they could be displayed in the
  scratch buffer."
    (let ((ret ""))
      (dolist (line lines ret)
        (setq ret (concat ret ";; " line "\n")))))

  (defvar my/raw-mottoes
    '(("困于心衡于虑而后作" "征于色发于声而后喻")
      ("学而不思则罔" "思而不学则殆")
      ("生于忧患" "死于安乐")
      ("与其感慨路难行" "不如马上出发")
      ("不以物喜 不以己悲" "先天下之忧而忧 后天下之乐而乐")
      ("悟已往之不谏" "知来者之可追")
      ("抽象")
      ("未来从今天开始")
      ("革命的道路" "同世界上一切事物活动的道路一样" "总是曲折 不是笔直的")
      ("老骥伏枥 志在千里" "烈士暮年 壮心不已")
      ("存地失人 人地皆失" "存人失地 人地皆存")
      ("胜兵先胜而后求战" "败兵先战而后求胜")
      ("胜可知而不可为")
      ("等死，死国可乎")
      ("冰冻三尺 非一日之寒")
      ("但行好事" "莫问前程")
      ("今我何功德" "曾不事农桑")))

  (defvar my/mottoes
    (let (ret)
      (dolist (raw-motto my/raw-mottoes ret)
        (setq ret (cons (my/process-raw-mottoes raw-motto) ret)))))

  (setq initial-scratch-message
        (concat ";; Hello, " user-full-name "\n"
                (nth (random (length my/mottoes))
                     my/mottoes)
                "\n"))
#+end_src

** Hide Async Shell Command Buffer

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               '("\\*Async Shell Command\\*.*"
                 (display-buffer-at-bottom display-buffer-pop-up-frame)
                 (window-height . 0.2)))
#+end_src

** Repeat Mode

Activate repeat mode to move among windows and repeat =M-x= commands.

#+begin_src emacs-lisp
  (repeat-mode)
#+end_src

** Variable-Pitch Mode

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'variable-pitch-mode)
#+end_src

** Find :dependency:

Windows provides a find program which accepts different arguments than
the Linux one. Emacs works out-of-the-box with Linux find program, so
on Windows I have to tell Emacs where the find program is, one that
accepts Linux find program conventional arguments.

#+begin_src emacs-lisp
  (if (eq system-type 'windows-nt)
      (setq find-program "C:/msys64/usr/bin/find.exe"))
#+end_src

** Hide Dos EOL

When working on Windows, sometimes I encounter files containing mixed
EOL characters. This would make some lines ended with additional
=^M=. To hide these annoying characters, I use the following function.

#+begin_src emacs-lisp
  (defun remove-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))
#+end_src

** prog-mode

#+begin_src emacs-lisp
  (defun prog-mode-setup ()
    (display-fill-column-indicator-mode t)
    (setq show-trailing-whitespace t)
    (electric-pair-mode t)
    (hs-minor-mode 1)
    (hl-line-mode 1))
  (add-hook 'prog-mode-hook 'prog-mode-setup)
#+end_src

** Documentation Style

Emacs 28 supports syntax highlighting for documentations in comments.

#+begin_src emacs-lisp
  (setq-default c-doc-comment-style
                '((java-mode . javadoc)
                  (pike-mode . autodoc)
                  (c-mode    . doxygen)
                  (c++-mode  . doxygen)))
#+end_src

** org-mode

#+begin_src emacs-lisp
  (use-package org
    :defer t
    :init
    (defvar my/org-babel-languages (list '(C . t)
                                         '(scheme . t)
                                         '(emacs-lisp . t)
                                         '(dot . t)))
    :config
    (setq org-ellipsis "…"
          org-auto-align-tags nil
          org-tags-column 0
          org-catch-invisible-edits 'show-and-error
          org-special-ctrl-a/e t
          org-hide-emphasis-markers t
          org-pretty-entities t
          org-babel-C-compiler "clang"
          org-babel-C++-compiler "clang++")
    (add-to-list 'org-modules 'org-habit t)
    (org-babel-do-load-languages 'org-babel-load-languages my/org-babel-languages)
    ;; The following code makes org emphasis markup covers more lines
    (setcar (nthcdr 4 org-emphasis-regexp-components) 5)
    (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
    ;; For preview tikz pictures
    (add-to-list 'org-latex-packages-alist '("" "tikz" t))
    (setq org-preview-latex-default-process 'dvisvgm))
#+end_src

*** Exporting Chinese Paragraph to HTML

Due to the difference between English and Chinese, there are some
extra spaces in exported Chinese paragraph when exporting to
HTML. These spaces are necessary since English uses spaces to separate
words, but Chinese don't. We have to override this behavior.

#+begin_src emacs-lisp
  (defadvice org-html-paragraph (before org-html-paragraph-advice
                                        (paragraph contents info) activate)
    "Join consecutive Chinese lines into a single long line without
     unwanted space when exporting org-mode to html."
    (let* ((origin-contents (ad-get-arg 1))
           (fix-regexp "[[:multibyte:]]")
           (fixed-contents
            (replace-regexp-in-string
             (concat
              "\\(" fix-regexp "\\) *\n *\\(" fix-regexp "\\)") "\\1\\2" origin-contents)))
      (ad-set-arg 1 fixed-contents)))
#+end_src

*** COMMENT Show org-agenda Buffer at Start-up

#+begin_src emacs-lisp
  (defun my/get-org-agenda-buffer ()
    (org-agenda-list)
    (get-buffer "*Org Agenda*"))
  (setq initial-buffer-choice #'my/get-org-agenda-buffer)
#+end_src

*** COMMENT capture

#+begin_src emacs-lisp
  (use-package org
               :defer t
               :config
               (setq org-default-notes-file (concat org-directory "/notes.org")))
#+end_src

*** Delete Link

This is inspired by this [[https://emacs.stackexchange.com/a/10714][stackexchange answer]].

#+begin_src emacs-lisp
  (defun my/org-remove-link ()
    "Remove an org link"
    (interactive)
    (if (org-in-regexp org-link-bracket-re 1)
        (save-excursion
          (let ((remove (list (match-beginning 0) (match-end 0))))
            (apply 'delete-region remove)))))
#+end_src

*** Replace Link

This function comes from this [[https://emacs.stackexchange.com/a/10714][stackexchange answer]].

#+begin_src emacs-lisp
  (defun my/org-replace-link-by-link-description ()
    "Replace an org link by its description or if empty its address"
    (interactive)
    (if (org-in-regexp org-link-bracket-re 1)
        (save-excursion
          (let ((remove (list (match-beginning 0) (match-end 0)))
                (description
                 (if (match-end 2)
                     (org-match-string-no-properties 2)
                   (org-match-string-no-properties 1))))
            (apply 'delete-region remove)
            (insert description)))))
#+end_src
** project

#+begin_src emacs-lisp
  (setq project-vc-extra-root-markers '(".project"))
#+end_src

** vc-svn

#+begin_src emacs-lisp
  (setq vc-svn-annotate-switches "-x --ignore-eol-style")
#+end_src

** nXML Mode

By default, nXML mode does not support hide and show certain blocks
(sections/nodes), this piece of code add this feature using hs-minor
mode.

Credit: https://stackoverflow.com/questions/944614/emacs-does-hideshow-work-with-xml-mode-sgml-mode

#+begin_src emacs-lisp
  (add-to-list 'hs-special-modes-alist
               (list 'nxml-mode
                     "<!--\\|<[^/>]*[^/]>"
                     "-->\\|</[^/>]*[^/]>"
                     "<!--"
                     'nxml-forward-element
                     nil))

  (add-hook 'nxml-mode-hook 'hs-minor-mode)
#+end_src

** Gnus

#+begin_src emacs-lisp
  (use-package gnus
    :bind
    (
     :map gnus-summary-mode-map
     ("v n" . gnus-summary-next-subject)
     ("v p" . gnus-summary-prev-subject)
     (:repeat-map gnus-summary-mode-repeat-map
                  ("n" . gnus-summary-next-subject)
                  ("p" . gnus-summary-prev-subject))))
#+end_src

*** News

Subscribing a RSS feed in Gnus can not be done by simply setting a
variable. Emacs has to execute the function
=gnus-group-make-rss-group=. This can be done in the Gnus group buffer
by typing =G R= and input the RSS feed URL. Thus, on every PC, the
subscription has to be done manually during the initial setup. See
[[info:gnus#RSS][gnus#RSS]] for more details.

RSS feeds:

- https://sachachua.com/blog/category/emacs-news/feed/
- https://protesilaos.com/codelog.xml

*** Mail in Emacs

I still can't get Gnus work, but the config I copied from this [[https://news.ycombinator.com/item?id=23420308][thread]]
does work. I'll paste them here for future reference.

#+begin_src emacs-lisp :tangle no
  (setq
   user-full-name "Chang Xiaoduan"
   user-mail-address "drcxd@sina.com"
   send-mail-function 'smtpmail-send-it
   smtpmail-smtp-server "smtp.sina.com"
   smtpmail-stream-type 'starttls
   smtpmail-smtp-service 587
   gnus-select-method
   '(nnimap "sina"
            (nnimap-address "imap.sina.com")
            (nnimap-server-port 993)
            (nnimap-stream ssl)
            (nnmail-expiry-wait immediate)))
#+end_src

The config I figured out by reading the manual myself is like this:

#+begin_src emacs-lisp
  (setq
   gnus-select-method '(nnimap "imap.sina.com")
   send-mail-function 'smtpmail-send-it
   smtpmail-smtp-server "smtp.sina.com"
   smtpmail-stream-type 'starttls
   smtpmail-servers-requiring-authorization "sina")
#+end_src

The second variable is necessary. Otherwise, I got an
"smtpmail-send-it: Sending failed: 530 Authentication required".
According to smtpmail.el, it should try again when the server is
requesting authentication. However, it does not. By setting the
variable ~smtpmail-servers-requiring-authorization~, smtpmail would ask
for authentication by default.

** Spell Checking

Currently I use Emacs' built-in spell checker, flyspell mode for spell
checking.

#+begin_src emacs-lisp
  (use-package flyspell
    :diminish flyspell-mode
    :hook
    ((text-mode . flyspell-mode)
     (prog-mode . flyspell-prog-mode)
     (latex-mode . (lambda () (flyspell-mode -1))))
    :bind
    ("C-c s b" . flyspell-buffer))
#+end_src

** Key Bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c E") 'eval-region)
  (global-set-key (kbd "C-c P") 'compile)
  (global-set-key (kbd "C-c b") 'switch-to-buffer)
  (global-set-key (kbd "C-c k") 'kill-buffer)
  (global-set-key (kbd "C-c S") 'shell-command)
  (global-set-key (kbd "C-c s t") 'hs-toggle-hiding)
  (global-set-key (kbd "C-c w m") 'woman)
  (global-set-key (kbd "C-<tab>") 'completion-at-point)
#+end_src

** Emacs As Server

#+begin_src emacs-lisp
  (require 'server)
  (setq server-client-instructions nil)
  (unless (server-running-p)
    (server-start))
#+end_src

** ediff

#+begin_src emacs-lisp
  (setq ediff-keep-variants nil)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

** imenu

#+begin_src emacs-lisp
  (use-package imenu
    :defer t
    :init
    (setq imenu-max-item-length 'Unlimited))
#+end_src

** Truncating Lines

I'd like to enable truncating long lines by default.

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

* Third-Party Packages

** =staraight.el=

#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
          "straight/repos/straight.el/bootstrap.el"
          (or (bound-and-true-p straight-base-dir)
              user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'org) ;; to fix org version mismatching
#+end_src

** Appearance

*** Diminish

I am using the built-in mode line, and it displays a symbol for all
the activated minor modes. This could makes the mode line messy,
because usually we have lots of minor modes turned on but we do not
need the visual cue on the mode line to tell us they are
enabled. Diminish is a good package to solve this problem.

#+begin_src emacs-lisp
  (use-package diminish
    :demand t
    :config
    (diminish 'abbrev-mode)
    (diminish 'visual-line-mode)
    (diminish 'eldoc-mode))

  (use-package hideshow
    :diminish hs-minor-mode)

  (use-package face-remap
    :diminish buffer-face-mode)
#+end_src

*** Unicode Support

#+begin_src emacs-lisp :noweb yes
  (use-package unicode-fonts
   :config
   (unicode-fonts-setup))
  ;; duplicate the font setup code here, otherwise it is override by
  ;; `unicode-fonts-setup'
  <<font-setup>>
#+end_src

*** Themes

**** Modus Themes
#+begin_src emacs-lisp
  (use-package modus-themes
    :defer t
    :init
    (defun my/modus-themes-custom-face ()
      (modus-themes-with-colors
        (custom-set-faces
         `(lsp-ui-doc-background ((,c :background ,bg-dim)))
         `(symbol-overlay-face-1 ((,c :inherit modus-themes-intense-blue)))
         `(symbol-overlay-face-2 ((,c :inherit modus-themes-intense-red)))
         `(symbol-overlay-face-3 ((,c :inherit modus-themes-intense-cyan)))
         `(symbol-overlay-face-4 ((,c :inherit modus-themes-intense-green)))
         `(symbol-overlay-face-5 ((,c :inherit modus-themes-intense-yellow)))
         `(symbol-overlay-face-6 ((,c :inherit modus-themes-intense-magenta)))
         `(symbol-overlay-face-7 ((,c :inherit modus-themes-subtle-red)))
         `(symbol-overlay-face-8 ((,c :inherit modus-themes-subtle-green))))))
    (defun my/use-modus-themes ()
      (interactive)
      (progn (global-set-key (kbd "C-c t g") 'modus-themes-select)
             (modus-themes-select 'modus-operandi)))
    (setq modus-themes-disable-other-themes t)
    :config
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs nil
          modus-themes-mixed-fonts t
          modus-themes-variable-pitch-ui t
          modus-themes-mode-line '(borderless)
          modus-themes-headings '((0 . (variable-pitch 1.61803))
                                  (1 . (variable-pitch 1.38196))
                                  (2 . (variable-pitch 1.23607))
                                  (3 . (variable-pitch 1.1459))
                                  (4 . (variable-pitch 1.09017))
                                  (5 . (variable-pitch 1.05573))
                                  (6 . (variable-pitch 1.03444))
                                  (7 . (variable-pitch 1.02129))
                                  (t . (variable-pitch 1.0))))
    :hook
    (modus-themes-after-load-theme . my/modus-themes-custom-face))
#+end_src

**** Standard Themes

#+begin_src emacs-lisp
  (use-package standard-themes
    :defer t
    :init
    (defun my/standard-themes-custom-face ()
      (standard-themes-with-colors
       (custom-set-faces
        `(lsp-ui-doc-background ((,c :background ,bg-dim)))
        `(symbol-overlay-face-1 ((,c :inherit standard-themes-intense-blue)))
        `(symbol-overlay-face-2 ((,c :inherit standard-themes-intense-red)))
        `(symbol-overlay-face-3 ((,c :inherit standard-themes-intense-cyan)))
        `(symbol-overlay-face-4 ((,c :inherit standard-themes-intense-green)))
        `(symbol-overlay-face-5 ((,c :inherit standard-themes-intense-yello)))
        `(symbol-overlay-face-6 ((,c :inherit standard-themes-intense-magenta)))
        `(symbol-overlay-face-7 ((,c :inherit standard-themes-subtle-red)))
        `(symbol-overlay-face-8 ((,c :inherit standard-themes-subtle-green))))))
    (defun my/use-standard-themes ()
      (interactive)
      (progn (global-set-key (kbd "C-c t g") 'standard-themes-toggle)
             (standard-themes-load-light)))
    (setq standard-themes-disable-other-themes t)
    :config
    (setq standard-themes-bold-constructs nil
          standard-themes-italic-constructs t
          standard-themes-mixed-fonts t
          standard-themes-variable-pitch-ui t
          standard-themes-headings '((0 . (variable-pitch 1.61803))
                                     (1 . (variable-pitch 1.38196))
                                     (2 . (variable-pitch 1.23607))
                                     (3 . (variable-pitch 1.1459))
                                     (4 . (variable-pitch 1.09017))
                                     (5 . (variable-pitch 1.05573))
                                     (6 . (variable-pitch 1.03444))
                                     (7 . (variable-pitch 1.02129))
                                     (t . (variable-pitch 1.0))))
    :hook
    (standard-themes-post-load . my/standard-themes-custom-face))
#+end_src

**** Ef Themes

#+begin_src emacs-lisp
  (use-package ef-themes
    :defer t
    :init
    (defun my/ef-themes-custom-face ()
      (ef-themes-with-colors
       (custom-set-faces
        `(lsp-ui-doc-background ((,c :background ,bg-dim)))
        `(symbol-overlay-face-1 ((,c :background ,bg-red-intense)))
        `(symbol-overlay-face-2 ((,c :background ,bg-green-intense)))
        `(symbol-overlay-face-3 ((,c :background ,bg-yellow-intense)))
        `(symbol-overlay-face-4 ((,c :background ,bg-blue-intense)))
        `(symbol-overlay-face-5 ((,c :background ,bg-magenta-intense)))
        `(symbol-overlay-face-6 ((,c :background ,bg-cyan-intense)))
        `(symbol-overlay-face-7 ((,c :background ,bg-red-subtle)))
        `(symbol-overlay-face-8 ((,c :background ,bg-green-subtle))))))
    (defun my/use-ef-themes ()
      (interactive)
      (progn (global-set-key (kbd "C-c t g") 'ef-themes-select)
             (ef-themes-select 'ef-cyprus)))
    (setq ef-themes-disable-other-themes t)
    :config
    (setq ef-themes-mixed-fonts t
          ef-themes-variable-pitch-ui t
          ef-themes-headings '((0 . (variable-pitch 1.61803))
                               (1 . (variable-pitch 1.38196))
                               (2 . (variable-pitch 1.23607))
                               (3 . (variable-pitch 1.1459))
                               (4 . (variable-pitch 1.09017))
                               (5 . (variable-pitch 1.05573))
                               (6 . (variable-pitch 1.03444))
                               (7 . (variable-pitch 1.02129))
                               (t . (variable-pitch 1.0))))
    :hook
    (ef-themes-post-load . my/ef-themes-custom-face))
#+end_src

*** Ligature

#+begin_src emacs-lisp :tangle no
  (use-package ligature
   :config
   (ligature-set-ligatures
    'prog-mode
    `("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
      ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
      "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
      "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
      "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
      "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
      "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
      "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
      ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
      "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
      "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
      "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
      "\\\\" "://"
      ("=" ,(rx (one-or-more "=")))
      ("-" ,(rx (one-or-more "-")))
      ("<" ,(rx "<" (one-or-more "-") ">"))))
   (global-ligature-mode t))
#+end_src

#+begin_src emacs-lisp
  (dolist (char/ligature-re
           `((?-  . ,(rx (or (or "-->" "-<<" "->>" "-|" "-~" "-<" "->")
                             (+ "-"))))
             (?/  . ,(rx (or (or "/==" "/=" "/>" "/**" "/*") (+ "/"))))
             (?*  . ,(rx (or (or "*>" "*/") (+ "*"))))
             (?<  . ,(rx (or (or "<<=" "<<-" "<|||" "<==>" "<!--" "<=>" "<||" "<|>" "<-<"
                                 "<==" "<=<" "<-|" "<~>" "<=|" "<~~" "<$>" "<+>" "</>"
                                 "<*>" "<->" "<=" "<|" "<:" "<>"  "<$" "<-" "<~" "<+"
                                 "</" "<*")
                             (+ "<")
                             (+ "-"))))
             (?:  . ,(rx (or (or ":?>" "::=" ":>" ":<" ":?" ":=") (+ ":"))))
             (?=  . ,(rx (or (or "=>>" "==>" "=/=" "=!=" "=>" "=:=") (+ "="))))
             (?!  . ,(rx (or (or "!==" "!=") (+ "!"))))
             (?>  . ,(rx (or (or ">>-" ">>=" ">=>" ">]" ">:" ">-" ">=") (+ ">"))))
             (?&  . ,(rx (+ "&")))
             (?|  . ,(rx (or (or "|->" "|||>" "||>" "|=>" "||-" "||=" "|-" "|>"
                                 "|]" "|}" "|=")
                             (+ "|"))))
             (?.  . ,(rx (or (or ".?" ".=" ".-" "..<") (+ "."))))
             (?+  . ,(rx (or "+>" (+ "+"))))
             (?\[ . ,(rx (or "[<" "[|")))
             (?\{ . ,(rx "{|"))
             (?\? . ,(rx (or (or "?." "?=" "?:") (+ "?"))))
             (?#  . ,(rx (or (or "#_(" "#[" "#{" "#=" "#!" "#:" "#_" "#?" "#(")
                             (+ "#"))))
             (?\; . ,(rx (+ ";")))
             (?_  . ,(rx (or "_|_" "__")))
             (?~  . ,(rx (or "~~>" "~~" "~>" "~-" "~@")))
             (?$  . ,(rx "$>"))
             (?^  . ,(rx "^="))
             (?\] . ,(rx "]#"))))
    (let ((char (car char/ligature-re))
          (ligature-re (cdr char/ligature-re)))
      (set-char-table-range composition-function-table char
                            `([,ligature-re 0 font-shape-gstring]))))
#+end_src

*** nerd-icons :dependency:

Add some fancy icons. Require nerd fonts:

https://www.nerdfonts.com/#home

#+begin_src emacs-lisp
  (use-package nerd-icons :demand t)

  (use-package nerd-icons-completion
    :after marginalia
    :config
    (nerd-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

  (use-package nerd-icons-dired
    :diminish nerd-icons-dired-mode
    :hook
    (dired-mode . nerd-icons-dired-mode))

  (use-package nerd-icons-corfu
    :demand t
    :after corfu
    :init
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package nerd-icons-ibuffer
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

*** logos

#+begin_src emacs-lisp
  (use-package olivetti :defer t
    :diminish olivetti-mode)
  (use-package logos
    :diminish logos-focus-mode
    :defer t
    :config
    (setq logos-outlines-are-pages t)
    (setq-default logos-hide-mode-line nil
                  logos-hide-buffer-boundaries nil
                  logos-hide-fringe t
                  logos-variable-pitch nil
                  logos-buffer-read-only nil
                  logos-olivetti t)
    (with-eval-after-load 'modus-themes
      (add-hook 'modus-themes-after-load-theme-hook #'logos-update-fringe-in-buffers))
    (with-eval-after-load 'ef-themes
      (add-hook 'ef-themes-post-load-hook #'logos-update-fringe-in-buffers))
    (with-eval-after-load 'standard-themes
      (add-hook 'standard-themes-post-load-hook #'logos-update-fringe-in-buffers))
    :bind
    (("C-c s l" . logos-focus-mode)
     ("C-c s n" . logos-narrow-dwim)
     ("C-c s k" . logos-backward-page-dwim)
     ("C-c s j" . logos-forward-page-dwim)))
#+end_src

*** spacious-padding

#+begin_src emacs-lisp
  ;;; This sample configuration comes from the package's manual

  (use-package spacious-padding
    :config
    ;; These is the default value, but I keep it here for visiibility.
    (setq spacious-padding-widths
          '( :internal-border-width 15
             :header-line-width 4
             :mode-line-width 6
             :tab-width 4
             :right-divider-width 30
             :scroll-bar-width 8
             :fringe-width 8))

    ;; Read the doc string of `spacious-padding-subtle-mode-line' as it
    ;; is very flexible and provides several examples.
    (setq spacious-padding-subtle-mode-line
          `( :mode-line-active 'default
             :mode-line-inactive vertical-border)))

  (spacious-padding-mode)
#+end_src

*** =lin=

#+begin_src emacs-lisp
  (use-package lin
    :init
    (setq lin-face 'lin-green
          lin-mode-hooks '(dired-mode-hook
                           grep-mode-hook
                           ibuffer-mode-hook
                           log-view-mode-hook
                           magit-log-mode-hook
                           occur-mode-hook
                           tabulated-list-mode-hook))
    (lin-global-mode 1))
#+end_src

** org-mode

*** org-mode Export: htmlize

htmlize is necessary to export code blocks to HTML.

#+begin_src emacs-lisp
  (use-package htmlize :defer t)
#+end_src

*** org-mode Appearance: org-modern

org-modern is a package that beautify org-mode. It changes the
appearance of header line, table, time stamp and other things.

Note that the Unicode characters used for ~org-modern-star~ and
~org-modern-list~ are carefully selected from the characters that are
supported by the fonts used in [[*Fonts and Faces]]. Otherwise, the
symbols are displayed using whatever font that can display such
symbols available on the system. In this case, a consistent appearance
can not be maintained on different systems.

#+begin_src emacs-lisp
  (use-package org-modern
    :defer t
    :config
    (setq
     org-modern-star 'replace
     org-modern-replace-stars '("⨀" "◎" "⎊" "✧" "☆" "⚛")
     org-modern-list '((43 . "•") (45 . "‣") (42 . "⁕")))
    :hook (org-mode . global-org-modern-mode))
#+end_src

*** org-mode & E-Mail: org-msg

#+begin_src emacs-lisp
  (use-package org-msg :defer t
    :config
    (setq
     org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
     org-msg-startup "hidestars indent inlineimages"
     ;; org-msg-greeting-fmt "\nHi%s,\n\n"
     ;; org-msg-recipient-names '(("jeremy.compostella@gmail.com" . "Jérémy"))
     ;; org-msg-greeting-name-limit 3
     org-msg-default-alternatives '((new		. (text html))
                                    (reply-to-html	. (text html))
                                    (reply-to-text	. (text)))
     org-msg-convert-citation t
     org-msg-signature "

  Regards,

  ,#+begin_signature
  --
  ,*Chang Xiaoduan*
  ,#+end_signature"))

  (org-msg-mode)
#+end_src

** Benchmark

Some Emacs users don't care about bootstrap time, they claim that they
only launch Emacs once and never close it until they turn off the
computer. However, I prefer to maintain a reasonable startup
time. It's always a good idea not to pay for what you are not
using.

#+begin_src emacs-lisp
  (use-package benchmark-init
               :init
               (require 'benchmark-init)
               :hook (after-init . benchmark-init/deactivate))
#+end_src

** Windows-Specific

*** powershell

Since I mostly use Emacs on Windows platform, I need this package to
interact nicely with the OS. Emacs built-in eshell mode and term mode
does not work properly on Windows. This package also comes with a
powershell mode to help editing powershell script files.

#+begin_src emacs-lisp
  (use-package powershell :defer t)
#+end_src

*** Alert & Notifications

On Linux, Emacs could use D-BUS to send desktop
notifications. However, I could not make dbus work on Windows, so I
found this alert-toast package to implement this feature.

#+begin_src emacs-lisp
  (if (eq system-type 'windows-nt)
      (use-package alert-toast
        :after alert
        :config
        (setq alert-default-style 'toast)))
#+end_src

** Life Quality

*** ripgrep

ripgrep is a multi-threaded version of grep. It is quite useful when
searching for certain text.

#+begin_src emacs-lisp
  (use-package ripgrep :defer t)
#+end_src

*** wgrep

wgrep allows users to modify grep/ripgrep outputs and save the changes
to each output's original location. It is a really powerful
interactive text file editing tool.

#+begin_src emacs-lisp
  (use-package wgrep :defer t)
#+end_src

*** zoom

By default, when multiple windows are displayed, Emacs split the
screen evenly among them. However, sometimes, this not what I
like. For example, when I am editing one buffer while reading the
content of another buffer, I may want to make the edited buffer takes
up most of the screen space. Emacs has a series of built-in commands
such as =enlarge-window= which allow users to adjust the window size as
they want. However, this process is repetitive and boring, because it
usually only enlarge/shrink the window by one row/column. zoom helps
me conveniently change the ration of windows sizes by simply execute
one single command.

#+begin_src emacs-lisp
  (use-package zoom
               :defer t
               :config
               (setq zoom-size '(0.618 . 0.618))
               :bind
               ("C-c z" . zoom)
               ("C-c Z" . zoom-mode))
#+end_src

*** scratch

This program allows user to create a scratch buffer of a certain mode,
so you can write anything in it.

#+begin_src emacs-lisp
  (use-package scratch
    :defer t
    :init
    (defun my/scratch-with-prefix ()
      (interactive)
      (let ((current-prefix-arg '(0)))
        (call-interactively 'scratch)))
    :bind
    ("C-c s c" . my/scratch-with-prefix))
#+end_src

*** Pomodoro and Timers

Sometimes I use the [[https://en.wikipedia.org/wiki/Pomodoro_Technique][pomodoro technique]] to force myself focus on my
task. I have tried [[https://github.com/SqrtMinusOne/pomm.el][pomm]] but I do not like its behavior. It
automatically switch to the next state, while I want to do this
manually. Then I found [[https://github.com/TatriX/pomidor/][pomidor]], this is exactly what I wanted.

Sometimes I just want to set a timer, and I found [[https://github.com/protesilaos/tmr][tmr]]. It's simple and
easy to use.

#+begin_src emacs-lisp
  (use-package tmr
    :defer t
    :init
    (if (eq system-type 'windows-nt)
        (progn
          (defun my/tmr-alert-notify (timer)
            (let ((title "TMR May Ring")
                  (body (tmr--long-description-for-finished-timer timer)))
              (alert body
                     :title title)))
          (setq tmr-timer-finished-functions (list #'my/tmr-alert-notify
                                                   #'tmr-print-message-for-finished-timer
                                                   #'tmr-acknowledge-minibuffer))))
    :bind
    (("C-c t T" . tmr)
     ("C-c t t" . tmr-with-description)
     ("C-c t r" . tmr-remove-finished)
     ("C-c t R" . tmr-remove)
     ("C-c t l" . tmr-tabulated-view)))

  (use-package pomidor
    :defer t
    :bind (("C-c t p" . pomidor))
    :config
    (setq
     pomidor-sound-tick nil
     pomidor-sound-tack nil
     pomidor-seconds (* 30 60)
     pomidor-break-seconds (* 10 60)
     pomidor-long-break-seconds (* 25 60))
    (if (eq system-type 'windows-nt)
        (setq pomidor-alert (lambda ()
                              (let ((message (pomidor-default-alert-message)))
                                (when message
                                  (alert message :title "Pomidor")))))))
#+end_src

*** ace-window

#+begin_src emacs-lisp
  (use-package ace-window
    :config
    (setq aw-dispatch-always t)
    :bind
    (("C-c o" . ace-window)
     ([remap other-window] . ace-window)))
#+end_src

** Programming

*** Completion

Completion is an important feature of modern IDE. With the help of
language server protocol, Emacs could also provide such service to
programmers.

**** corfu

corfu is a completion front end package. That is, it is responsible to
display the completion candidates on the screen.

#+begin_src emacs-lisp
  (use-package corfu
   :init
   (setq corfu-auto nil
         corfu-cycle t
         corfu-quit-at-boundary nil
         corfu-quit-no-match nil
         corfu-preview-current nil
         corfu-excluded-modes '(gud-mode))
   ;; disalbe corfu in gud-mode, see
   ;; https://github.com/minad/corfu/issues/157 for more detail
   (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (corfu-mode 1)))
   :hook
   (minibuffer-setup . corfu-enable-in-minibuffer)
   :bind
   (:map corfu-map
         ("C-n" . corfu-next)
         ("C-p" . corfu-previous)
         ("<tab>" . corfu-next)
         ("S-<tab>" . corfu-previous)
         ("C-g" . corfu-quit)
         ("<escape>" . corfu-quit)
         ("SPC" . corfu-insert-separator))
   )

  (unless (display-graphic-p)
    (progn
      (use-package corfu-terminal :defer t)
      (corfu-terminal-mode +1)))

  (global-corfu-mode)
#+end_src

**** cape

cape provides a set of completion backends. A completion back ends
decides what are the completion candidates.

#+begin_src emacs-lisp
  (use-package company :defer t)
  (use-package cape
   :demand t
   :config
   (add-to-list 'completion-at-point-functions #'cape-dabbrev)
   (add-to-list 'completion-at-point-functions #'cape-file)
   (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-clang)))
#+end_src

*** COMMENT Code Formatting :dependency:

If the code keeps a consistent and easy-to-read format, it will be
much easier to read and maintain. However, manually formatting the
code cannot assure consistency and is also a boring process. We can
use our time to think about more valuable problems. Thus, using a nice
code formatting tool is necessary.

#+begin_src emacs-lisp
  (use-package clang-format :defer t)
  (use-package inheritenv :defer t)
  (use-package language-id :defer t)
  (use-package format-all :defer t)
#+end_src

*** flycheck

flycheck is an error checking package, which displays inline visual
hint for possible code warning or error. Currently, I only use it as
a facility for lsp.

#+begin_src emacs-lisp
  (use-package flycheck :defer t :diminish flycheck-mode)
#+end_src

*** hl-todo

This package highlights certain keywords in comments and string
literals.

#+begin_src emacs-lisp
  (use-package hl-todo
   :defer t
   :config
   (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO" warning bold)
          ("FIXME" error bold)
          ("HACK" font-lock-constant-face bold)
          ("REVIEW" font-lock-keyword-face bold)
          ("NOTE" success bold)
          ("DEPRECATED" font-lock-doc-face bold)
          ("BUG" error bold)))
   :hook
   (prog-mode . hl-todo-mode))
#+end_src

*** git-gutter :dependency:

This packages add visual hint on the fringe to indicate which part of
the file is added/deleted/modified against the latest version in the
version control system.

#+begin_src emacs-lisp
  (use-package git-gutter
   :diminish git-gutter-mode
   :defer t
   :config
   (setq git-gutter:handled-backends '(git svn))
   :hook
   (prog-mode . git-gutter-mode)
   :bind
   ("C-c G" . git-gutter))
#+end_src

*** evil-nerd-commenter

Commenting a piece of code might be one of the most frequent
operations a programmer performs. Thus, we need a convenient and smart
package to help us perform this task. evil-nerd-commenter fits my
need.

#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
   :defer t
   :bind
   (("C-c c" . evilnc-comment-or-uncomment-lines)
    ("C-c C" . evilnc-copy-and-comment-lines)))
#+end_src

*** Symbol Highlighting

When inspecting a piece of code, I need to highlight some of the
symbols to help me quickly locate the places they are referenced.
symbol-overlay is the best package I have known for this task.

#+begin_src emacs-lisp
  (use-package symbol-overlay
   :defer t
   :bind
   (("C-c s p" . symbol-overlay-put)
    ("C-c s r" . symbol-overlay-remove-all))
   :config
   (setq symbol-overlay-inhibit-map t))
#+end_src

*** lsp :dependency:

Language server protocol is a powerful tool. It enables Eamcs provide
IDE-like functions, such as auto-completion,
jump-to-definition/declaration, find-references and even
variable-rename.

#+begin_src emacs-lisp
  (use-package lsp-mode
   :defer t
   :init
   (defun corfu-lsp-setup ()
     (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
           '(orderless))
     (advice-add #'lsp-completion-at-point :around #'cape-wrap-noninterruptible))
   :config
   (setq lsp-headerline-breadcrumb-enable nil
         lsp-semantic-tokens-apply-modifiers nil
         lsp-semantic-tokens-enable t
         read-process-output-max (* 1024 1024)) ;; to increase lsp performance
   (if (and (package-installed-p 'corfu) (package-installed-p 'cape))
       (progn
         (add-hook 'lsp-completion-mode-hook #'corfu-lsp-setup)
         (setq lsp-completion-provider :none)))
   :hook
   (lua-mode . (lambda () (setq-local lsp-enable-indentation nil)))
   :bind
   (("C-c l l" . lsp)
    :map lsp-mode-map
    ("C-c l c" . lsp-find-declaration)
    ("C-c l f" . lsp-find-definition)
    ("C-c l o" . lsp-clangd-find-other-file)
    ("C-c l r" . lsp-workspace-restart)
    ("C-c l d" . lsp-workspace-shutdown)
    ("C-c l a" . lsp-execute-code-action)
    ("C-c l n" . lsp-rename)
    ("C-c l t" . lsp-semantic-tokens-mode)))

  (use-package lsp-ui
   :defer t
   :bind
   (:map lsp-ui-mode-map
         ("C-c l g" . lsp-ui-doc-glance)
         ("C-c l F" . lsp-ui-doc-focus-frame))
   :config
   (setq lsp-ui-doc-show-with-mouse nil))

  (use-package consult-lsp
   :after (lsp-mode consult)
   :bind
   (:map lsp-mode-map
         ("C-c l S" . consult-lsp-symbols)
         ("C-c l s" . consult-lsp-file-symbols)
         ("C-c l i" . consult-lsp-diagnostics)))

  (with-eval-after-load 'lsp-clangd
    (setq lsp-clients-clangd-args
          '("--completion-style=detailed"
            "--header-insertion=never"
            "--function-arg-placeholders=0"
            "--background-index"
            "--background-index-priority=low"
            "--pch-storage=memory")))

  (add-to-list 'safe-local-eval-forms '(lsp))
#+end_src

*** citre

citre is a package that use tags files to provide IDE-like features
such as completion and jumping to definition. Generally speaking,
solutions based on tags are not as accurate as solutions based on
LSP. However, it is still useful when the project can not be compiled.

#+begin_src emacs-lisp
  (use-package citre
    :defer t
    :init
    (require 'citre-config))
#+end_src

*** COMMENT Syntax Highlighting

Eamcs has built-in syntax highlighting support, however it is based on
regular expression. This means it would not be correct in every
situation.

lsp also provides syntax highlighting support. This requires a backend
server, and sometimes it is too heavy to practice. What if we are
editing a simple one-file program but still want better syntax
highlighting?

I find the package tree-sitter. Its solution is better than regular
expression but still not a full functional compiler. This means it is
better than the built-in syntax highlighting solution but still not
totally correct. However, it is light-weight enough, so it is still a
viable choice.

After Emacs 29, tree-sitter has been integrated into Emacs core. There
is no need to install these additional packages anymore. Instead,
Emacs need to be compiled with tree-sitter library. Also, users have
to compile language specific shared library themselves to support
specific language major mode.

#+begin_src emacs-lisp :tangle no
  (use-package tree-sitter
   :diminish
   :defer t
   :hook
   ((c-mode . tree-sitter-mode)
    (c++-mode . tree-sitter-mode)
    (lua-mode . tree-sitter-mode)
    (tree-sitter-after-on . tree-sitter-hl-mode)))

  (use-package tree-sitter-langs
   :defer t)
#+end_src

*** Programming Languages

**** C++

#+begin_src emacs-lisp :tangle no
  (defun my/c-indent-then-complete ()
    (interactive)
    (if (= 0 (c-indent-line-or-region))
        (completion-at-point)))
  (with-eval-after-load 'cc-mode
    (define-key c++-mode-map [remap c-indent-line-or-region] 'my/c-indent-then-complete))
#+end_src

**** Lua

#+begin_src emacs-lisp
  (use-package lua-mode :defer t)
#+end_src

**** Scheme

Scheme is a dialect of Lisp. It is also the language used in the book
/Structure and Interpretation of Computer Programs/ (SICP). Emacs
provide nice support for scheme language. It has a built-in package
scheme-mode. The command ~run-scheme~ starts an inferior scheme process
inside Emacs. After that, you can evaluate scheme expression in any
scheme-mode buffer. The expression is evaluated in the inferior scheme
process.

***** Use Scheme in org-mode

To execute scheme code in org-mode, org-babel's [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-scheme.html][document]] requires
[[https://www.nongnu.org/geiser/][Geiser]].

#+begin_src emacs-lisp
  (use-package geiser :defer t)
#+end_src

Geiser is an Emacs front end of a Scheme interpreter, and it supports
multiple implementations. For more information about Geiser, check its
documentation in Emacs' INFO pages (after installing the package).

****** A Minor Issue

I was using org 9.5 and I found org-babel failed to execute scheme
code in org-mode buffer. After a simple search, I found one who had
encountered the same
issue. https://www.mail-archive.com/emacs-orgmode@gnu.org/msg142485.html

It turns out there is a bug in org and I have to upgrade it to version
9.6 to fix it.

***** Scheme Implementations

****** COMMENT Chicken :dependency:

The first scheme implementation I used is the [[https://call-cc.org/][chicken
compiler]]. According to its [[https://wiki.call-cc.org/emacs#builtin-scheme-support][documents]], to use it with Emacs built-in
support is easy.

#+begin_src emacs-lisp :tangle no
  (setq scheme-program-name "csi -:c")
#+end_src

However, it needs some additional setup to work with org-babel (see
its [[https://wiki.call-cc.org/emacs#geiser][documents]]). What's more, it does not support Windows platform
nicely. First, there is no pre-built binaries or installers. Though
MSYS2-MinGW 64 package manager could install a package, it is actually
not viable. I have to build the compiler myself. Second,
=chicken-install=, which is a prerequisite for it to work with
org-babel, cannot work correctly on Windows. Chicken requires users to
apply for an account to report bug, which is not convenient.

****** COMMENT Chez :dependency:

After I have found that I cannot make chicken work with org-babel on
Windows, I switch to [[https://github.com/cisco/ChezScheme][Chez]]. It has nice Windows support, e.g. a Windows
installer. It also host a repository on github so it is easy to report
a bug. Finally, it does not require additional setup to work with
Emacs. The only thing I have to do is to expose its binary =scheme= in
the =PATH=, or customize ~geiser-chez-binary~.

#+begin_src emacs-lisp
  (use-package geiser-chez :defer t)
#+end_src

****** Racket :dependency:

If I am only using Scheme then Chez is good enough, however, I use
scheme mainly to learn SICP. SICP has some customized code which are
used as dependencies in some exercises. There is a Racket package
(https://docs.racket-lang.org/sicp-manual/index.html
https://github.com/sicp-lang/sicp) that implements these customized
code so that users do not have to input and evaluate them every time
they execute code depends on them. Thus, [[https://racket-lang.org/][Racket]] becomes a better
choice than Chez when learning SICP.

What makes things interesting is that Racket is not only an
implementation of Scheme, but also itself a programming
language. There is a major-mode package =racket-mode= for it. There is
also a specialized org-babel language support package for Racket:
[[https://github.com/hasu/emacs-ob-racket][eamcs-ob-racket]] , which is only available on github. If I want to use
this package, I have no other choice but use =git submodule= to link it
to my configuration repository.

Note that if you want to use =racket-mode= then you should not install
=geiser-racket=. These two packages conflict with each other on some
particular settings. For example, when opening a =.rkt= file, if
=geiser-racket= is installed, then it opens it in =scheme-mode=. This
prevents you use some of the functions provided by =racket-mode=, since
it requires the major mode being =racket-mode=.

Thus, I have to choose one of the two solutions: =geiser-racket= plus
native org-babel support for scheme; or =racket-mode= plus
=emacs-ob-racket=.

I have tried the latter for some time, because I tried to find a way
to use the Racket package for SIPC conveniently in
org-babel. =emacs-ob-racket= allows me to add a header argument to the
code block to declare that the code depends on the SICP package, while
the native support for Scheme language or =geiser-racket= does not
provide such features.

However, =racket-mode= and =eamcs-ob-racket= makes completion when editing
Racket code block difficult, comparing with =geiser-racket=. Actually,
there seems no completion in the org-mode code blocks at all. Thus, I
switch back to =geiser-racket=. This is also because I found that adding
~(require sicp)~ at the beginning of any org-mode Scheme code block
imports the code defined in the SICP package, which is almost equally
convenient as the header argument.

Note that evaluating a Scheme code block in org-mode may be slow. This
can be optimized by having a dedicated REPL for the org-mode
buffer. Thus, org-babel does not have to launch a new instance of
Racket backend each time you evaluate a code block.

#+begin_src emacs-lisp
  (use-package geiser-racket :defer t)
#+end_src

**** Graphviz Dot

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode :defer t)
#+end_src

*** Unreal :dependency:

I am working with Unreal Engine, using Emacs + clangd + lsp-mode as my
development environment. I find that I frequently execute some
operations on my Unreal project, such as generate compilation
database, generate header files, build the project and debug the
project. To accelerate these processes, I have developed the following
routines.

**** Variables

Most of the operations are done using the Unreal Build Tool (UBT). All
operations must be associated with a particular target and
platform. These variables are defined for convenience.

#+begin_src emacs-lisp
  (defvar my/ubt-location nil "Unreal Build Tool file location.")

  (defvar my/unreal-opts '("DebugGame"
                           "Development")
    "A list of frequently used optimization levels for Unreal projects.")

  (defvar my/unreal-platforms '("Win64")
    "A list of frequently used target platforms for Unreal projects.")

  (defun my/build-ubt-op-string (project opt platform &optional editor)
    "Return a string ready to be appended with an UBT operation."
    (let ((name (file-name-base project)))
      (format-message "%s %s %s%s %s %s"
                      my/ubt-location
                      project
                      name
                      (if editor "Editor" "")
                      opt
                      platform)))
#+end_src

**** Build the Project

#+begin_src emacs-lisp
  (defun my/unreal-build-project (project opt platform &optional editor)
    "Build an Unreal project."
    (interactive
     (let ((completion-ignore-case t))
       (list (read-file-name "Project file path: ")
             (completing-read "Optimization level: " my/unreal-opts nil nil)
             (completing-read "Platform: " my/unreal-platforms nil nil)
             current-prefix-arg)))
    (async-shell-command (my/build-ubt-op-string project opt platform editor)))
#+end_src

**** Generating Compilation Database

clangd + lsp-mode requires a compilation database to work. UBT
provides a mode which generates the compilation database.

#+begin_src emacs-lisp
  (defun my/unreal-generate-clang-database (project opt platform &optional editor)
    "Generate compilation database for an Unreal project."
    (interactive
     (let ((completion-ignore-case t))
       (list (read-file-name "Project file path: ")
             (completing-read "Optimization level: " my/unreal-opts nil nil)
             (completing-read "Platform: " my/unreal-platforms nil nil)
             current-prefix-arg)))
    (async-shell-command
     (format-message
      "%s -mode=GenerateClangDatabase"
      (my/build-ubt-op-string project opt platform editor))))
#+end_src

**** Generate Header Files

Unreal Header Tool (UHT) is a program which scans user code and
generate code to implement the reflection code. Its methodology is to
use some macros which expands to file name and line number. Then it
generates code which substitutes those macros. As a result, once the
macro's location has changed, the file will fail the
compilation. However, changing of line number is frequent. This makes
clangd fail to compile the code, thus providing less useful
information when editing. The solution is to generate code every time
some macro's line number has changed.

#+begin_src emacs-lisp
  (defun my/unreal-generate-header-file (project opt platform &optional editor)
    "Generate header files for specified Unreal project."
    (interactive
       (let ((completion-ignore-case t))
         (list (read-file-name "Project file path: ")
               (completing-read "Optimization level: " my/unreal-opts nil nil)
               (completing-read "Platform: " my/unreal-platforms nil nil)
               current-prefix-arg)))
    (async-shell-command
     (format-message
      "%s -SkipBuild"
      (my/build-ubt-op-string project opt platform editor))))
#+end_src

** Templates & Snippets

When programming, we have to write some boilerplate code: the
structure of the piece of code is conventional, we only need to
replace some key text in it, for example, the name of the variable.

There is a well-known package for this task: yasnippet. However, this
package is not maintained actively for more than two years (today is
2022-12-10, and its last commit time is 2020-06-04). Thus, I switch to
another package, tempel. Though it is a new package, it has its own
advantages. First, it relies on Emacs built-in Tempo library. Second,
its simple enough to learn and work with. Third, it is maintained
actively. However, since yasnippet is well-known, some other packages,
such as lsp-mode, depends on it somehow, so I still install it.

#+begin_src emacs-lisp
  (use-package tempel
   :defer t
   :init
   ;; Setup completion at point
   (defun tempel-setup-capf ()
     ;; Add the Tempel Capf to `completion-at-point-functions'.
     ;; `tempel-expand' only triggers on exact matches. Alternatively use
     ;; `tempel-complete' if you want to see all matches, but then you
     ;; should also configure `tempel-trigger-prefix', such that Tempel
     ;; does not trigger too often when you don't expect it. NOTE: We add
     ;; `tempel-expand' *before* the main programming mode Capf, such
     ;; that it will be tried first.
     (setq-local completion-at-point-functions
                 (cons #'tempel-expand
                       completion-at-point-functions)))
   :bind
   (("M-+" . tempel-insert)
    ("M-*" . tempel-complete))
   :hook
   ((prog-mode . tempel-setup-capf)
    (text-mode . tempel-setup-capf)))

  (use-package yasnippet
   :diminish yas-minor-mode
   :defer t
   :hook
   (prog-mode . yas-minor-mode)
   :bind
   ("C-c Y" . yas-reload-all))
#+end_src

** Citation

Currently I am using org-cite, citar plus citeproc to deal with
citation issues.

*** citar

#+begin_src emacs-lisp
  (use-package citar
    :init
    (setq org-cite-global-bibliography '("~/org-roam/references.bib")
          org-cite-insert-processor 'citar
          org-cite-follow-processor 'citar
          org-cite-activate-processor 'citar
          citar-bibliography org-cite-global-bibliography
          org-cite-export-processors '((t . (csl "modern-language-association.csl"))))
    :hook
    (org-mode . citar-capf-setup))

  (use-package citar-embark
    ;; :defer t
    :after (citar embark)
    ;; :no-require
    :diminish citar-embark-mode
    :config (citar-embark-mode))

  ;; You can get the csl style files from
  ;; https://github.com/citation-style-language/styles

  ;; (setq org-cite-csl-styles-dir "path/to/styles/dir")
#+end_src

Also, =org-cite-csl-styles-dir= must be set for the csl styles to work.

** Taking Notes

As a text editor, Emacs is a good place to take notes. There are also
packages helps you organize your notes. The most popular one is
org-roam. A lighter-weight choice is denote. These two packages are
often used to practice a note-taking methodology called [[https://zettelkasten.de/introduction/][Zettelkasten]].

*** org-roam

#+begin_src emacs-lisp
  (use-package org-roam
    :defer t
    :init
    (setq
     org-roam-database-connector 'sqlite-builtin
     org-roam-directory "~/org-roam/"
     org-roam-node-display-template (concat "${title} " (propertize "${tags}" 'face 'org-tag))
     org-roam-capture-templates '(("d" "default" plain "%?" :target
                                   (file+head "%<%Y%m%d%H%M%S>.org" "#+title: ${title}\n")
                                   :unnarrowed t)
                                  ("p" "private" plain "%?" :target
                                   (file+head "private/%<%Y%m%d%H%M%S>.org.gpg" "#+title: ${title}\n")
                                   :unnarrowed t))
     org-roam-dailies-capture-templates '(("d" "default" entry "* %?" :target
                                           (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))
                                          ("p" "private" entry "* %?" :target
                                           (file+head "%<%Y-%m-%d>.org.gpg" "#+title: %<%Y-%m-%d>\n"))))
    :config
    (org-roam-db-autosync-mode)
    :bind
    (("C-c n f" . org-roam-node-find)
     ("C-c n i" . org-roam-node-insert)
     ("C-c n c" . org-roam-capture)
     ("C-c n d" . org-roam-dailies-goto-today)
     ("C-c n D" . org-roam-dailies-goto-date)
     ("C-c n t" . org-roam-tag-add)
     ("C-c n T" . org-roam-tag-remove)
     ("C-c n r" . org-roam-ref-add)
     ("C-c n R" . org-roam-ref-remove)
     ("C-c n b" . org-roam-buffer-toggle)
     ("C-c n B" . org-roam-buffer)
     ("C-c n a" . org-roam-alias-add)
     ("C-c n A" . org-roam-alias-remove)))

  (use-package org-roam-ui :defer t
    :diminish ((org-roam-ui-mode . "") (org-roam-ui-follow-mode . "")))
#+end_src

**** consult-org-roam

Utility package makes org-roam using consult to search notes, forward
and backward links. It improves the workflow and thus efficiency.

#+begin_src emacs-lisp
  (use-package consult-org-roam
     :after (org-roam consult)
     :diminish consult-org-roam-mode
     :init
     (setq consult-org-roam-buffer-enabled nil)
     ;; Activate the minor mode
     (consult-org-roam-mode 1)
     :custom
     ;; Use `ripgrep' for searching with `consult-org-roam-search'
     (consult-org-roam-grep-func #'consult-ripgrep)
     ;; Configure a custom narrow key for `consult-buffer'
     (consult-org-roam-buffer-narrow-key ?r)
     ;; Display org-roam buffers right after non-org-roam buffers
     ;; in consult-buffer (and not down at the bottom)
     ;; (consult-org-roam-buffer-after-buffers t)
     :config
     ;; Eventually suppress previewing for certain functions
     ;; (consult-customize
     ;;  consult-org-roam-forward-links
     ;;  :preview-key (kbd "M-."))
     :bind
     ;; Define some convenient keybindings as an addition
     ;; ("C-c n f" . consult-org-roam-file-find)
     ("C-c n l" . consult-org-roam-backlinks)
     ("C-c n L" . consult-org-roam-forward-links)
     ("C-c n s" . consult-org-roam-search))
#+end_src

**** citar-org-roam

A necessary package to integrate citar with org-roam, thus,
bibliographic notes can be easily created in org-roam context.

#+begin_src emacs-lisp
  (use-package citar-org-roam
    :diminish citar-org-roam-mode
    :after (citar org-roam)
    ;; :no-require
    :config
    (citar-org-roam-mode)
    (add-to-list 'org-roam-capture-templates '("r" "reference" plain "%?" :target
                                               (file+head "%<%Y%m%d%H%M%S>.org" "#+title: ${note-title}\n")
                                               :unnarrowed t) t)
    (setq citar-org-roam-capture-template-key "r"))
#+end_src

** Completion

*** vertico

Emacs has a tons of variables, commands and documents. When you
exploring them, vertico provides a much more informative interface for
you to browse those information.

#+begin_src emacs-lisp
  (use-package vertico
    :demand t
    :config
    (setq read-extended-command-predicate #'command-completion-default-include-p
          enable-recursive-minibuffers t))
  (vertico-mode)
#+end_src

*** orderless

orderless allows the completion systems using a different completion
strategy. The default completion systems completes based on prefix
matching. orderless enable it to use a fuzzy matching strategy. This
is quite useful because you do not always remember exactly what you
want to search. Sometimes, you do not even know if the things in your
head exist or not, but you want to use the completions system as a
tool to verify your assumption. Orderless completion is really helpful
in these situations.

#+begin_src emacs-lisp
  (use-package orderless
    :demand t
    :config
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** marginalia

marginalia works together with vertico, it provides more information
of a variable or function in the completion interface. This may help
you locate your target more quickly.

#+begin_src emacs-lisp
  (use-package marginalia :defer t)
  (marginalia-mode)
#+end_src

*** consult

consult works together with vertico. It helps you complete among lots
of things, such as buffers, file contents, grep results, find results,
etc..

#+begin_src emacs-lisp
  (use-package consult
    :demand t
    :init
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    (defun consult-ripgrep-with-prefix ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-ripgrep)))
    :config
    (setq consult-fontify-max-size 262144) ;; 262144 = 2 ^ 18
    (setq consult-preview-excluded-files '(".*epub"))

    ;; this handles problems when consult results contains
    ;; Chinese characters
    (if (eq system-type 'windows-nt)
        (progn
          ;; https://github.com/minad/consult/issues/572
          (add-to-list 'process-coding-system-alist
                       '("[rR][gG]" . (utf-8 . gbk-dos)))
          ;; https://github.com/minad/consult/issues/601
          (setq consult-find-args (concat find-program " . "))))
    :bind
    (([remap switch-to-buffer] . consult-buffer)
     ("C-c i" . consult-line)
     ("C-c r" . consult-ripgrep-with-prefix)
     ("C-c R" . consult-ripgrep)
     ("C-c I" . consult-imenu)
     ("C-c f" . consult-fd)
     ("C-c H" . consult-org-heading)))
#+end_src

*** embark

embark allows users perform certain tasks in the completion
interface. This reduces the number of operations users have to
perform. For example, when you are trying to delete a certain file,
you have to =find-file= to open the directory the file is located. Then
mark the file to be deleted in dired and finally execute the delete
operation. With embark, you can simply browse to the file in
completion system and then execute =embark-act= then use its delete file
function to delete the current completion candidate. Much more
convenient.

#+begin_src emacs-lisp
  (use-package embark
               :defer t
               :bind ("<f5>" . embark-act))
  (use-package embark-consult :defer t)
#+end_src

** projectile

Project can be applied to organize anything you are working on. Not
only programming project, but also writing project, note-taking
project, etc.. projectile helps you browse project files, search
contents in project and even run and test project (if it is a
programming project).

#+begin_src emacs-lisp
  (use-package projectile
   :diminish projectile-mode
   :defer t
   :bind
   (("C-c p f" . projectile-find-file)
    ("C-c p i" . projectile-invalidate-cache)
    ("C-c p s" . projectile-switch-project)
    ("C-c p d" . projectile-dired)
    ("C-c p r" . projectile-ripgrep))
   :config
   (projectile-global-mode))
#+end_src

** magit :dependency:

magit is the well-known Emacs interface for git.

#+begin_src emacs-lisp
  (use-package magit
   :defer t
   :bind
   ("C-c M" . magit))
#+end_src

** Key Binding

*** meow

meow is a modal editing package. It looks like evil, but I think it
suits Emacs more than evil. meow provides supports for many Emacs
packages native key bindings, such as org-mode. For example, when
using meow, you can execute the command =org-babel-tangle= by pressing
=SPC c v t= out-of-the-box, while its original key binding is =C-c C-v
t=. It also works well with my own native key bindings. When using
meow, I do not have to change my original key binding settings. I only
add some additional configuration specific to meow.

#+begin_src emacs-lisp
  (use-package meow
     :demand t
     :init
     (defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
       ;; (meow-motion-overwrite-define-key
       ;;  ;; '("j" . meow-next)
       ;;  ;; '("k" . meow-prev)
       ;;  '("<escape>" . ignore))
       (meow-leader-define-key
        ;; SPC j/k will run the original command in MOTION state.
        ;; '("j" . "H-j")
        ;; '("k" . "H-k")
        ;; Use SPC (0-9) for digit arguments.
        '("1" . meow-digit-argument)
        '("2" . meow-digit-argument)
        '("3" . meow-digit-argument)
        '("4" . meow-digit-argument)
        '("5" . meow-digit-argument)
        '("6" . meow-digit-argument)
        '("7" . meow-digit-argument)
        '("8" . meow-digit-argument)
        '("9" . meow-digit-argument)
        '("0" . meow-digit-argument)
        '("/" . meow-keypad-describe-key)
        '("?" . meow-cheatsheet))
       (meow-normal-define-key
        '("0" . meow-expand-0)
        '("9" . meow-expand-9)
        '("8" . meow-expand-8)
        '("7" . meow-expand-7)
        '("6" . meow-expand-6)
        '("5" . meow-expand-5)
        '("4" . meow-expand-4)
        '("3" . meow-expand-3)
        '("2" . meow-expand-2)
        '("1" . meow-expand-1)
        '("-" . negative-argument)
        '(";" . meow-reverse)
        '("," . meow-inner-of-thing)
        '("." . meow-bounds-of-thing)
        '("[" . meow-beginning-of-thing)
        '("]" . meow-end-of-thing)
        '("a" . meow-append)
        '("A" . meow-open-below)
        '("b" . meow-back-word)
        '("B" . meow-back-symbol)
        '("c" . meow-change)
        '("d" . meow-delete)
        '("D" . meow-backward-delete)
        '("e" . meow-next-word)
        '("E" . meow-next-symbol)
        '("f" . meow-find)
        '("g" . meow-cancel-selection)
        '("G" . meow-grab)
        '("h" . meow-left)
        '("H" . meow-left-expand)
        '("i" . meow-insert)
        '("I" . meow-open-above)
        '("j" . meow-next)
        '("J" . meow-next-expand)
        '("k" . meow-prev)
        '("K" . meow-prev-expand)
        '("l" . meow-right)
        '("L" . meow-right-expand)
        '("m" . meow-join)
        '("M" . magit)
        '("n" . meow-search)
        '("o" . meow-block)
        '("O" . meow-to-block)
        '("p" . meow-yank)
        '("P" . meow-yank-pop)
        ;; '("q" . meow-quit)
        ;; '("Q" . meow-goto-line)
        '("q" . evilnc-comment-or-uncomment-lines)
        '("Q" . evilnc-copy-and-comment-lines)
        '("r" . meow-replace)
        '("R" . meow-swap-grab)
        '("s" . meow-kill)
        '("S" . shell-command)
        '("t" . meow-till)
        '("u" . meow-undo)
        '("U" . meow-undo-in-selection)
        '("v" . meow-visit)
        '("w" . meow-mark-word)
        '("W" . meow-mark-symbol)
        '("x" . meow-line)
        '("X" . meow-goto-line)
        '("y" . meow-save)
        '("Y" . meow-sync-grab)
        '("z" . meow-pop-selection)
        '("'" . repeat)
        '("<escape>" . ignore)
        '("=" . indent-region)
        '("`" . delete-horizontal-space)
        '("{" . backward-paragraph)
        '("}" . forward-paragraph)
        '("/" . hs-toggle-hiding))
       ;; disable SPC in motion mode since it might be used
       (define-key meow-motion-state-keymap (kbd "SPC") nil))
     :config
     (setq meow-replace-state-name-list
          '((normal . "[N]")
            (motion . "[M]")
            (keypad . "[K]")
            (insert . "[I]")
            (beacon . "[B]")))
     (setq meow-keypad-leader-dispatch "C-c")
     (setq meow-mode-state-list
           '((fundamental-mode . normal)
             (text-mode . normal)
             (prog-mode . normal)
             (conf-mode . normal)
             (bibtex-mode . normal)))
     ;; use motion state by default
     (defun my/meow-guess-state (state)
       'motion)
     (advice-add 'meow--mode-guess-state :filter-return #'my/meow-guess-state)
     (meow-setup)
     (meow-global-mode 1)
     (global-set-key (kbd "<f6>") 'meow-keypad)
     :hook
     (meow-insert-exit . (lambda ()
                           (if (and meow-normal-mode (not buffer-read-only))
                               (delete-trailing-whitespace (pos-bol) (pos-eol))))))
#+end_src

**** A Note About KEYPAD Mode

Meow's default behavior is to add =C-`= prefix to any key with no
prefix. This looks counter-intuitive to me. Meow is trying to simulate
Emacs native key bindings, but this behavior is the contrary of Emacs
native style. For example, command =view-echo-area-message= is bound to
=C-h e=, and command =view-external-packages= is bound to =C-h
C-e=. Translated into Meow, =view-echo-area-message= is bound to =SPC h
SPC e=, while =view-external-packages= is bound to =SPC h
e=. =view-external-packages= has more key strokes in native key bindings,
but has less key stokes in Meow. =view-echo-area-message= has less key
strokes in native key bindings, but has more key strokes in Meow.

Also, Meow has a fallback mechanism. Meow maps =C-h k= to =SPC h SPC k=,
and =C-h C-k= to =SPC h k=. However, when =C-h C-k= is unbound, =SPC h k= will
automatically invokes the command bound to =C-h k=. This is convenient,
but it introduces uncertainty. Meow users could not know the command
=SPC h k= invokes is bound to which native key binding: =C-h C-k= or =C-h
k=.

The author's explanation for this behavior is [[https://github.com/meow-edit/meow/issues/47#issuecomment-1377206836][here]]. I try to
understand and accept the author's idea, but I still found that if
KEYPAD does not automatically add =C-= prefix would be better. I have
asked the author to add an option to let users make their own choices,
but the author seems not agree with me.

Thus, I tried to dig into the source code and modify them by
myself. In =meow-keypad.el=, there is a function
=meow-keypad-self-insert=, which defines how KEYPAD translate key
strokes. If we exchange the code dealing with literal and non-prefix
cases, then we change KEYPAD's behavior to not automatically add =C-=
prefix, but only when =SPC= is pressed. This modification introduces a
new problem: which-key prompt for KEYPAD key bindings does not update
to fit this change. There are two additional functions
=meow--keypad-format-keys= and =meow--keypad-get-keymap-for-describe=, they all
have similar structures to that of =meow-keypad-self-insert=, deal with
them so that Meow generate the correct hints.

*** COMMENT which-key

With so many key bindings, it is impossible to memorize all of
them. which-key is a package that displays all viable commands and
their key bindings when you are in the middle of a sequence of key
binding.

#+begin_src emacs-lisp
  (use-package which-key
   :diminish
   :config
   (which-key-mode))
#+end_src

** EBooks

*** calibre Interface

**** COMMENT calibredb

#+begin_src emacs-lisp
  (use-package calibredb
    :defer t)
#+end_src

To use this package, several other variables have to be set:

- =calibredb-root-dir=
- =calibredb-db-dir=
- =calibredb-program=
- =calibredb-library-alist=


However, the values of these variables depends on the actual location
of the calibre libraries on the current computer. Thus, it is better
to put these configurations in the local =custom.el= file.

**** calibre

This is an alternative to calibredb. I prefer this package over
calibredb. I have added some custom functions to open the directory
that contains a book in Dired.

#+begin_src emacs-lisp
  (use-package calibre
    :defer t
    :config
    (use-package calibre-library
      :ensure nil
      :config
      (defun calibre-book--path (book)
        "Return the path to the directory of BOOK."
        (let ((path (calibre-book-path book)))
          (file-name-concat (calibre--library)
                            path)))
      (defun calibre-library-open-book-dir (book)
        "Open the directory of BOOK."
        (interactive (list (tabulated-list-get-id))
                     calibre-library-mode)
        (find-file (calibre-book--path book)))
      :bind
      (:map calibre-library-mode-map
            ("O" . calibre-library-open-book-dir))))
#+end_src

This package also requires some local settings, for example, we have
to specify the location of the library:

#+begin_src emacs-lisp :tangle no
  (setq calibre-libraries '(("nonficition" . "~/Documents/Non Fiction Library/")))
#+end_src

Also, we can specify an external program to open a certain format of a book:

#+begin_src emacs-lisp :tangle no
  (setq calibre-external-programs '((pdf . "acrobat")))
#+end_src

Otherwise, the book is opened inside Emacs.

*** nov

nov is a package that allows you read EPUB files inside Emacs.

#+begin_src emacs-lisp
  (use-package nov
    :defer t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    (setq nov-text-width t)
    :hook
    (nov-mode . (lambda () (setq truncate-lines nil))))
#+end_src

* Load Custom File

Finally, after all the other settings have been done, we load the
local customization file.

#+begin_src emacs-lisp
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src
