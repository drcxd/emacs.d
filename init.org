#+property: header-args:emacs-lisp :tangle init.el :comments org
#+STARTUP: overview

* Abstract

Trying literate programming with my emacs configuration. This is
inspired by http://alhassy.com/emacs.d/. Protesilaos
(https://protesilaos.com/) uses such a method as well. His
configuration (https://git.sr.ht/~protesilaos/dotfiles) is also a good
resource to learn about Emacs.

* Emacs Native Configurations

This part contains configurations about all Emacs native options and
built-in packages. This part does not depends on any third-party
packages.

** Android Environment Settings

#+begin_src emacs-lisp :tangle (if (eq system-type 'android) "early-init.el" "no")
  (setenv "PATH" (format "%s:%s" "/data/data/com.termux/files/usr/bin"
  		       (getenv "PATH")))
  (push "/data/data/com.termux/files/usr/bin" exec-path)
#+end_src

** Garbage Collection Settings

Adjust garbage collection thresholds during startup, and restore it
after startup. It is said that this reduces the boot time, but I have
not seen any observable change.

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5)

  (defvar my/file-name-handler-alist file-name-handler-alist)
  (defvar my/vc-handled-backends vc-handled-backends)

  (setq file-name-handler-alist nil
        vc-handled-backends nil)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 1024 1024 128)
                    gc-cons-percentage 0.2
                    file-name-handler-alist my/file-name-handler-alist
                    vc-handled-backends my/vc-handled-backends)))
#+end_src

** Native Compilation

Native compilation tends to generate a lot of warnings, which
interrupts whatever work you are doing. Disabling them reduces
distraction.

#+begin_src emacs-lisp
  (when (native-comp-available-p)
    (setq native-comp-async-report-warnings-errors 'silent) ; Emacs 28 with native compilation
    (setq native-compile-prune-cache t)) ; Emacs 29
#+end_src

** COMMENT Package

I use package.el to manage almost all the packages I use, except those
are only available on github. package.el is flexible since it can
easily be configured to use a local repository or a mirror. This is
really helpful when your network environment is not good.

#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives
        '(
          ("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("nongnu" . "https://elpa.nongnu.org/nongnu/")
          ;; ("melpa-stable" . "https://stable.melpa.org/packages/")

          ;; use local repository
          ;; ("local-melpa" . "~/elpa-mirror-master/melpa/")
          ;; ("local-gnu" . "~/elpa-mirror-master/gnu/")
          ;; ("local-nongnu" . "~/elpa-mirror-master/nongnu/")

          ;; Use either 163 or tsinghua mirror repository when official melpa
          ;; is slow or shutdown.

          ;; ;; {{ Option 1: 163 mirror repository:
          ;; ("gnu" . "https://mirrors.163.com/elpa/gnu/")
          ;; ("melpa" . "https://mirrors.163.com/elpa/melpa/")
          ;; ("melpa-stable" . "https://mirrors.163.com/elpa/stable-melpa/")
          ;; ("nongnu" . "https://mirrors.163.com/elpa/nongnu/")
          ;; ;; }}

          ;; ;; {{ Option 2: tsinghua mirror repository
          ;; ;; @see https://mirror.tuna.tsinghua.edu.cn/help/elpa/ on usage:
          ;; ;; ("gnu"   . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
          ;; ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
          ;; ("melpa-stable" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/stable-melpa/")
          ;; }}

          ;; gitlab mirror
          ;; ("melpa" . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/melpa/")
          ;; ("org"   . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/org/")
          ;; ("gnu"   . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/gnu/")
          ))
  ;; (package-refresh-contents)
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

** Who am I?

#+begin_src emacs-lisp
  (setq user-full-name "Chang Xiaoduan"
        user-mail-address "drcxd@sina.com")
#+end_src

** Custom File Location

It is good to place the custom file in =.emacs.d= directory. This way,
we have all the files related to Emacs in one single directory. Some
users do not like the idea of a custom file since Emacs' Custom writes
to it. However, I consider the custom file as a location that you can
add some machine-dependent settings. For example, you can specify the
location of a binary file. I find it helpful since I am using Emacs on
different computers and different OSes. Thus, keep a volatile and
local configuration file helps solve some specific issues.

#+begin_src emacs-lisp
  (setq custom-file (locate-user-emacs-file "custom.el"))
#+end_src

** Frame Settings

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html][Frame parameters]] can be used to control the appearance of Emacs
frame. We can use these parameters to hide menu bar, adjust frame's
position and width, etc..

#+begin_src emacs-lisp :tangle "early-init.el"
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** uniquify

When two buffers of the same name are opened, Emacs has to uniquify
them so you can distinguish between them.

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-ignore-buffers-re "^\\*")
#+end_src

** ibuffer

ibuffer is a buffer list all opened buffers in Emacs. You can use it
to manage these buffers just as you manage files in dired.

#+begin_src emacs-lisp
  ;; (with-eval-after-load 'ibuffer
  ;;   ;; Use human readable Size column instead of original one
  ;;   (define-ibuffer-column size-h
  ;;     (:name "Size" :inline t)
  ;;     (cond
  ;;      ((> (buffer-size) 1000000)
  ;;       (format "%7.1fM" (/ (buffer-size) 1000000.0)))
  ;;      ((> (buffer-size) 1000)
  ;;       (format "%7.1fk" (/ (buffer-size) 1000.0)))
  ;;      (t
  ;;       (format "%8d" (buffer-size)))))

  ;;   (setq ibuffer-expert t
  ;;         ibuffer-show-empty-filter-groups nil
  ;;         ibuffer-display-summary nil)

  ;;   (setq ibuffer-saved-filter-groups
  ;;         (quote (("default"
  ;;                  ("code" (or (mode . emacs-lisp-mode)
  ;;                              (mode . cperl-mode)
  ;;                              (mode . c-mode)
  ;;                              (mode . java-mode)
  ;;                              (mode . idl-mode)
  ;;                              (mode . web-mode)
  ;;                              (mode . lisp-mode)
  ;;                              (mode . js2-mode)
  ;;                              (mode . c++-mode)
  ;;                              (mode . lua-mode)
  ;;                              (mode . cmake-mode)
  ;;                              (mode . ruby-mode)
  ;;                              (mode . css-mode)
  ;;                              (mode . objc-mode)
  ;;                              (mode . sql-mode)
  ;;                              (mode . python-mode)
  ;;                              (mode . php-mode)
  ;;                              (mode . sh-mode)
  ;;                              (mode . json-mode)
  ;;                              (mode . scala-mode)
  ;;                              (mode . go-mode)
  ;;                              (mode . erlang-mode)))

  ;;                  ("dired" (or (mode . dired-mode)
  ;;                               (mode . sr-mode)))

  ;;                  ("erc" (mode . erc-mode))

  ;;                  ("planner" (or (name . "^\\*Calendar\\*$")
  ;;                                 (name . "^diary$")
  ;;                                 (mode . muse-mode)
  ;;                                 (mode . org-mode)
  ;;                                 (mode . org-agenda-mode)))

  ;;                  ("emacs" (or (name . "^\\*scratch\\*$")
  ;;                               (name . "^\\*Messages\\*$")))

  ;;                  ("gnus" (or (mode . message-mode)
  ;;                              (mode . bbdb-mode)
  ;;                              (mode . mail-mode)
  ;;                              (mode . gnus-group-mode)
  ;;                              (mode . gnus-summary-mode)
  ;;                              (mode . gnus-article-mode)
  ;;                              (name . "^\\.bbdb$")
  ;;                              (name . "^\\.newsrc-dribble")))))))
  ;;   (defun ibuffer-mode-hook-setup ()
  ;;     (unless (eq ibuffer-sorting-mode 'filename/process)
  ;;       (ibuffer-do-sort-by-filename/process))
  ;;     (ibuffer-switch-to-saved-filter-groups "default"))

  ;;   (add-hook 'ibuffer-mode-hook 'ibuffer-mode-hook-setup)

  ;;   ;; Modify the default ibuffer-formats
  ;;   (setq ibuffer-formats
  ;;         '((mark modified read-only " "
  ;;                 (name 18 18 :left :elide)
  ;;                 " "
  ;;                 (size-h 9 -1 :right)
  ;;                 " "
  ;;                 (mode 16 16 :left :elide)
  ;;                 " "
  ;;                 filename-and-process)))

  ;;   (setq ibuffer-filter-group-name-face 'font-lock-doc-face))

  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

** Mode Line

#+begin_src emacs-lisp
  (setq display-time-24hr-format t)
  (display-time)
  (column-number-mode)
  ;; put mode lines at the top of buffers
  ;; (setq-default header-line-format mode-line-format)
  ;; (setq-default mode-line-format nil)

  ;; NOTE: I give up this configuration since the header line is also
  ;; used by some special buffer, for example, org-edit-special. In such
  ;; a buffer, I lose all the information provided by the mode
  ;; line. This is not acceptable so I switch back to the bottom mode
  ;; line setting.
#+end_src

** Auto Backup

By default, Emacs will automatically generate a backup file every time
you edit an existing file. If your file name is =fname.txt=, then it
generates a backup file named =fname.txt=. This can quickly make the
directory messy, so I prefer disable this feature.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
#+end_src

** Auto Save

Emacs can automatically save edited files after some certain idle
time. This feature is disabled by default. I would like to enable it
to prevent accidental loss of data. The idle time should not be too
short since this would incur frequently disk I/O.

#+begin_src emacs-lisp
  ;; auto-save-visited-interval must be set before
  ;; auto-save-visited-mode is enabled, otherwise, changing its value
  ;; does not take effect
  (setq auto-save-visited-interval 30)
  (auto-save-visited-mode 1)
#+end_src

** Auto Revert

I turn on auto-revert-mode because sometimes when a file is edited by
some external programs, edit it again and save it in Emacs will
conflict with the external changes. Enable auto-revert-mode eliminate
the chances of such problems.

#+begin_src emacs-lisp
  (global-auto-revert-mode)
  (setq auto-revert-verbose nil)
#+end_src

** Splash Screen

By default, Emacs shows a welcome screen every time it is
launched. This might be useful to new Emacs users, but for experienced
users, displaying the =*scratch*= buffer by default may be more
productive. You could also execute the command =about-emacs= to display
the splash screen manually.

#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
#+end_src

** No Tab Character

Tab could be translated to different length spaces by different
editors. To avoid such a difference, simply avoid using tab.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Recent Files

It would be convenient to quickly open the file you have edited in
your last Emacs session. With recentf-mode, you do not have to input
the location of the file every time you visit it, but choose from a
maintained recent file list.

#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src

** Dired

dired is the facility Emacs uses to manage files. It's the file
explorer of Emacs. You can perform many file operations in dired.

#+begin_src emacs-lisp
  (setq dired-kill-when-opening-new-dired-buffer t
        dired-guess-shell-alist-user '(("\\.pdf\\'" "okular &")))
  (defun dired-mode-setup ()
    "Setup dired."
    ;; global-auto-revert-mode does not work for dired
    (auto-revert-mode)
    (dired-hide-details-mode))
  (add-hook 'dired-mode-hook 'dired-mode-setup)
  (with-eval-after-load 'dired
    (require 'dired-x))
#+end_src

** Mottoes

I would like the welcome message displayed in the scratch buffer be
some mottoes selected randomly from a pre-defined list.

#+begin_src emacs-lisp
  (defun my/process-raw-mottoes (lines)
    "Process motto strings so that they could be displayed in the
    scratch buffer."
    (let ((ret ""))
      (dolist (line lines ret)
        (setq ret (concat ret ";; " line "\n")))))

  (defvar my/raw-mottoes
    '(("困于心衡于虑而后作" "征于色发于声而后喻")
      ("学而不思则罔" "思而不学则殆")
      ("生于忧患" "死于安乐")
      ("与其感慨路难行" "不如马上出发")
      ("不以物喜 不以己悲" "先天下之忧而忧" "后天下之乐而乐")
      ("悟已往之不谏" "知来者之可追")
      ("抽象")
      ("未来从今天开始")
      ("革命的道路" "同世界上一切事物活动的道路一样" "总是曲折 不是笔直的")
      ("老骥伏枥 志在千里" "烈士暮年 壮心不已")
      ("存地失人 人地皆失" "存人失地 人地皆存")
      ("胜兵先胜而后求战" "败兵先战而后求胜")
      ("胜可知而不可为")
      ("等死 死国可乎")
      ("冰冻三尺 非一日之寒")
      ("但行好事" "莫问前程")
      ("今我何功德" "曾不事农桑")
      ("All problems in computer science can be solved by another level of indirection,"
       "except for the problem of too many layers of indirection.") ;; David Wheeler
      ("希望越大 失望越大" "能力越小 责任越小")
      ("人固有一死" "或重于泰山 或轻于鸿毛" "用之所趋异也")
      ("水至清则无鱼" "人至察则无徒")
      ("是我们改变了世界" "还是世界改变了我和你")
      ("君子求诸己" "小人求诸人")
      ("君子和而不同" "小人同而不和")
      ("让子弹飞一会儿")
      ("鞠躬尽瘁" "死而后已")
      ("塞翁失马" "焉知非福")
      ("福兮祸之所倚" "祸兮福之所伏")
      ("人生代代无穷已" "江月年年望相似")
      ("担当生前事" "何计身后评")
      ("The spirit is willing" "but the flesh is weak")))

  (setq initial-scratch-message
        (concat ";; Hello, " user-full-name "\n\n"
                (my/process-raw-mottoes (seq-random-elt my/raw-mottoes))
                "\n"))

  (defun my/show-motto ()
    (interactive)
    (message (my/process-raw-mottoes (seq-random-elt my/raw-mottoes))))
#+end_src

** Window Management

#+begin_src emacs-lisp
  (setq switch-to-buffer-in-dedicated-window 'pop
        switch-to-buffer-obey-display-actions nil
        ;; left top right bottom
        window-sides-slots '(1 0 0 0))

  (add-to-list 'display-buffer-alist
               '("\\*Async Shell Command\\*.*"
                 (display-buffer-reuse-window
                  display-buffer-at-bottom
                  display-buffer-pop-up-frame)
                 (window-height . 0.2)))

  (add-to-list 'display-buffer-alist
               '((or (major-mode . Info-mode)
                     (major-mode . help-mode)
                     (major-mode . messages-buffer-mode))
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side . left)
                 (window . root)
                 (window-width . 80)))

  (add-to-list 'display-buffer-alist
               '((or (major-mode . dired-mode)
                     (major-mode . process-menu-mode))
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side . left)
                 (window . root)
                 (window-width . 0.2)))

  (add-to-list 'display-buffer-alist
               '("^\\*.*eshell\\*$" display-buffer-in-direction
                 (direction . bottom)
                 (window . root)
                 (window-height . 0.3)))
#+end_src

** Repeat Mode

Activate repeat mode to move among windows and repeat =M-x= commands.

#+begin_src emacs-lisp
  (repeat-mode)
#+end_src

** Variable-Pitch Mode

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'variable-pitch-mode)
#+end_src

** Find :dependency:

Windows provides a find program which accepts different arguments than
the Linux one. Emacs works out-of-the-box with Linux find program, so
on Windows I have to tell Emacs where the find program is, one that
accepts Linux find program conventional arguments.

#+begin_src emacs-lisp
  (if (eq system-type 'windows-nt)
      (setq find-program "C:/msys64/usr/bin/find.exe"))
#+end_src

** prog-mode

#+begin_src emacs-lisp
  (defun prog-mode-setup ()
    (display-fill-column-indicator-mode t)
    (setq show-trailing-whitespace t)
    (electric-pair-mode t)
    (hs-minor-mode 1)
    (hl-line-mode 1))
  (add-hook 'prog-mode-hook 'prog-mode-setup)
#+end_src

** Documentation Style

Emacs 28 supports syntax highlighting for documentations in comments.

#+begin_src emacs-lisp
  (setq-default c-doc-comment-style
                '((java-mode . javadoc)
                  (pike-mode . autodoc)
                  (c-mode    . doxygen)
                  (c++-mode  . doxygen)))
#+end_src

** project

#+begin_src emacs-lisp
  (setq project-vc-extra-root-markers '(".project"))
#+end_src

** vc-svn

#+begin_src emacs-lisp
  (setq vc-svn-annotate-switches "-x --ignore-eol-style")
#+end_src

** nXML Mode

By default, nXML mode does not support hide and show certain blocks
(sections/nodes), this piece of code add this feature using hs-minor
mode.

Credit: https://stackoverflow.com/questions/944614/emacs-does-hideshow-work-with-xml-mode-sgml-mode

#+begin_src emacs-lisp
  (add-to-list 'hs-special-modes-alist
               (list 'nxml-mode
                     "<!--\\|<[^/>]*[^/]>"
                     "-->\\|</[^/>]*[^/]>"
                     "<!--"
                     'nxml-forward-element
                     nil))

  (add-hook 'nxml-mode-hook 'hs-minor-mode)
#+end_src

** Gnus

#+begin_src emacs-lisp
  (use-package gnus
    :bind
    (:map gnus-summary-mode-map
     ("v n" . gnus-summary-next-subject)
     ("v p" . gnus-summary-prev-subject)
     (:repeat-map gnus-summary-mode-repeat-map
                  ("n" . gnus-summary-next-subject)
                  ("p" . gnus-summary-prev-subject))))
#+end_src

*** COMMENT RSS Feeds

I no longer read RSS feeds in Gnus for its complexity to setup and
inconvenience to use. Now I switch to [[*elfeed]].

Subscribing a RSS feed in Gnus can not be done by simply setting a
variable. Emacs has to execute the function
=gnus-group-make-rss-group=. This can be done in the Gnus group buffer
by typing =G R= and input the RSS feed URL. Thus, on every PC, the
subscription has to be done manually during the initial setup. See
[[info:gnus#RSS][gnus#RSS]] for more details.

RSS feeds:

- https://sachachua.com/blog/category/emacs-news/feed/
- https://protesilaos.com/codelog.xml

*** Mail

Reading E-mail in Emacs is difficult to configure since most E-mail
service requires complicated authentication methods. Now a days I
mostly read and write E-mail on Thunderbird. However, I keep this
configuration in case I need to read/write E-mail on Emacs.

#+begin_src emacs-lisp
  (setq
   gnus-select-method '(nnimap "imap.sina.com")
   send-mail-function 'smtpmail-send-it
   smtpmail-smtp-server "smtp.sina.com"
   smtpmail-stream-type 'starttls
   smtpmail-servers-requiring-authorization "sina")
#+end_src

The last variable is necessary. Otherwise, I got "smtpmail-send-it:
Sending failed: 530 Authentication required".  According to
=smtpmail.el=, it should try again when the server is requesting
authentication. However, it does not. By setting the variable
~smtpmail-servers-requiring-authorization~, smtpmail would ask for
authentication by default.

** Spell Checking

Currently I use Emacs' built-in spell checker, flyspell mode for spell
checking.

#+begin_src emacs-lisp
  (use-package flyspell
    :diminish flyspell-mode
    :hook
    ((text-mode . flyspell-mode)
     (prog-mode . flyspell-prog-mode)
     (latex-mode . (lambda () (flyspell-mode -1))))
    :bind
    ("C-c s b" . flyspell-buffer))
#+end_src

** Emacs As Server

#+begin_src emacs-lisp
  (require 'server)
  (setq server-client-instructions nil)
  (unless (server-running-p)
    (server-start))
#+end_src

** ediff

#+begin_src emacs-lisp
  (setq ediff-keep-variants nil
        ediff-show-clashes-only t
        ediff-split-window-function 'split-window-horizontally)
#+end_src

** imenu

#+begin_src emacs-lisp
  (use-package imenu
    :defer t
    :init
    (setq imenu-max-item-length 'Unlimited))
#+end_src

** Filling and Wrapping

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
  ;; (add-hook 'text-mode-hook (lambda () (setq truncate-lines nil)))
  ;; Enable wrapping after any Chinese characters
  ;; More information about this issue: https://debbugs.gnu.org/cgi/bugreport.cgi?bug=29364
  (setq word-wrap-by-category t)
#+end_src

** Completion

#+begin_src emacs-lisp
  (setq completion-ignore-case t)
#+end_src

** Utility Code

#+begin_src emacs-lisp
  (defun my/curly->round (start end)
    "Replace { with (, and } with ) in region."
    (interactive "r")
    (replace-string-in-region "{" "(" start end)
    (replace-string-in-region "}" ")" start end))

  (defun my/visit-emacs-config ()
    "Open init.org."
    (interactive)
    (find-file (locate-user-emacs-file "init.org")))

  (defvar my/workout-plan
    '(("Push" . ("Barbell Bench Press"
                 "Inclined Barbell Bench Press"
                 "Dumbbell Bench Press"
                 "Triceps Pushdown")) ;; Monday
      ("Pull" . ("Barbell Deadlift"
                 "One-Arm Dumbbell Row"
                 "Lat Pull Down"
                 "Alternating Dumbbell Curl")) ;; Tuesday
      ("Upper Body" . ("The Press"
                       "Seated Cable Row"
                       "Close-Grip Bench Press"
                       "Dumbbell Rear Lateral Raise")) ;; Wednesday
      ("Squat" . ("Barbell Squat"
                  "Lunge"
                  "Hanging Leg Lift"))))

  (defun my/insert-workout-plan ()
    (interactive)
    (let ((plan (if current-prefix-arg
                    (let ((key (completing-read "Workout plan: " (mapcar 'car my/workout-plan))))
                      (assoc key my/workout-plan))
                  (let* ((weekday (string-to-number (format-time-string "%u"))))
                    (nth (- weekday 1) my/workout-plan)))))
      (mapc (lambda (exercise)
              (insert (format "| %s | %s | | | | | |\n"
                              (format-time-string "%Y/%m/%d")
                              exercise)))
            (cdr plan))))

  ;; (global-set-key (kbd "C-c w") 'my/insert-workout-plan)
#+end_src

When working on Windows, sometimes I encounter files containing mixed
EOL characters. This would make some lines ended with additional
=^M=. To hide these annoying characters, I use the following function.

#+begin_src emacs-lisp
  (defun remove-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))
#+end_src

** Key Bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c e") 'eval-region)
  (global-set-key (kbd "C-c b") 'switch-to-buffer)
  (global-set-key (kbd "C-c k") 'kill-buffer)
  (global-set-key (kbd "C-c S") 'shell-command)
  (global-set-key (kbd "C-<tab>") 'completion-at-point)
  (global-set-key (kbd "C-c t S") 'global-text-scale-adjust)
  (global-set-key (kbd "C-c t s") 'text-scale-adjust)
  (global-set-key (kbd "C-c v l") 'visual-line-mode)
  (global-set-key (kbd "C-c v a") 'auto-fill-mode)
#+end_src

* Third-Party Packages

** elpaca

Using elpaca requires disabling the built-in package manager.

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq package-enable-at-startup nil)
#+end_src


#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1 :inherit ignore
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

  ;; Uncomment for systems which cannot create symlinks:
  (if (eq system-type 'windows-nt)
      (elpaca-no-symlink-mode))

  (elpaca elpaca-use-package
    ;; Enable Elpaca's use-package support
    (elpaca-use-package-mode))
  ;; Block until package is installed/activated so we can use it at the top-level below.
  (elpaca-wait)
#+end_src

** COMMENT Appearance

*** Diminish

I am using the built-in mode line, and it displays a symbol for all
the activated minor modes. This could makes the mode line messy,
because usually we have lots of minor modes turned on but we do not
need the visual cue on the mode line to tell us they are
enabled. Diminish is a good package to solve this problem.

#+begin_src emacs-lisp
  (use-package diminish
    :demand t
    :ensure (:wait t))

  (use-package hideshow
    :ensure nil
    :diminish hs-minor-mode)

  (use-package face-remap
    :ensure nil
    :diminish buffer-face-mode)
#+end_src

*** Unicode Support

#+begin_src emacs-lisp :noweb yes
  (use-package unicode-fonts
    :ensure t
    :config
    (unicode-fonts-setup))
#+end_src

*** Themes

**** Modus Themes

#+begin_src emacs-lisp
  (use-package modus-themes
    :ensure t
    :defer t
    :init
    (defun my/modus-themes-custom-face ()
      (modus-themes-with-colors
        (custom-set-faces
         ;; Faces used by lsp-mode package
         `(lsp-ui-doc-background ((,c :background ,bg-dim)))
         ;; Faces used by symbol overlay package
         `(symbol-overlay-face-1 ((,c :inherit modus-themes-intense-blue)))
         `(symbol-overlay-face-2 ((,c :inherit modus-themes-intense-red)))
         `(symbol-overlay-face-3 ((,c :inherit modus-themes-intense-cyan)))
         `(symbol-overlay-face-4 ((,c :inherit modus-themes-intense-green)))
         `(symbol-overlay-face-5 ((,c :inherit modus-themes-intense-yellow)))
         `(symbol-overlay-face-6 ((,c :inherit modus-themes-intense-magenta)))
         `(symbol-overlay-face-7 ((,c :inherit modus-themes-subtle-red)))
         `(symbol-overlay-face-8 ((,c :inherit modus-themes-subtle-green))))))
    (defun my/use-modus-themes ()
      (interactive)
      (progn (global-set-key (kbd "C-c t g") 'modus-themes-select)
             (modus-themes-select 'modus-operandi)))
    (setq modus-themes-disable-other-themes t)
    :config
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs nil
          modus-themes-mixed-fonts t
          modus-themes-variable-pitch-ui t
          modus-themes-mode-line '(borderless)
          modus-themes-headings '((0 . (variable-pitch 1.61803))
                                  (1 . (variable-pitch 1.38196))
                                  (2 . (variable-pitch 1.23607))
                                  (3 . (variable-pitch 1.1459))
                                  (4 . (variable-pitch 1.09017))
                                  (5 . (variable-pitch 1.05573))
                                  (6 . (variable-pitch 1.03444))
                                  (7 . (variable-pitch 1.02129))
                                  (t . (variable-pitch 1.0))))
    :hook
    (modus-themes-after-load-theme . my/modus-themes-custom-face))
#+end_src

**** COMMENT Standard Themes

#+begin_src emacs-lisp
  (use-package standard-themes
    :defer t
    :init
    (defun my/standard-themes-custom-face ()
      (standard-themes-with-colors
       (custom-set-faces
        `(lsp-ui-doc-background ((,c :background ,bg-dim)))
        `(symbol-overlay-face-1 ((,c :inherit standard-themes-intense-blue)))
        `(symbol-overlay-face-2 ((,c :inherit standard-themes-intense-red)))
        `(symbol-overlay-face-3 ((,c :inherit standard-themes-intense-cyan)))
        `(symbol-overlay-face-4 ((,c :inherit standard-themes-intense-green)))
        `(symbol-overlay-face-5 ((,c :inherit standard-themes-intense-yello)))
        `(symbol-overlay-face-6 ((,c :inherit standard-themes-intense-magenta)))
        `(symbol-overlay-face-7 ((,c :inherit standard-themes-subtle-red)))
        `(symbol-overlay-face-8 ((,c :inherit standard-themes-subtle-green))))))
    (defun my/use-standard-themes ()
      (interactive)
      (progn (global-set-key (kbd "C-c t g") 'standard-themes-toggle)
             (standard-themes-load-light)))
    (setq standard-themes-disable-other-themes t)
    :config
    (setq standard-themes-bold-constructs nil
          standard-themes-italic-constructs t
          standard-themes-mixed-fonts t
          standard-themes-variable-pitch-ui t
          standard-themes-headings '((0 . (variable-pitch 1.61803))
                                     (1 . (variable-pitch 1.38196))
                                     (2 . (variable-pitch 1.23607))
                                     (3 . (variable-pitch 1.1459))
                                     (4 . (variable-pitch 1.09017))
                                     (5 . (variable-pitch 1.05573))
                                     (6 . (variable-pitch 1.03444))
                                     (7 . (variable-pitch 1.02129))
                                     (t . (variable-pitch 1.0))))
    :hook
    (standard-themes-post-load . my/standard-themes-custom-face))
#+end_src

**** COMMENT Ef Themes

#+begin_src emacs-lisp
  (use-package ef-themes
    :defer t
    :init
    (defun my/ef-themes-custom-face ()
      (ef-themes-with-colors
       (custom-set-faces
        `(lsp-ui-doc-background ((,c :background ,bg-dim)))
        `(symbol-overlay-face-1 ((,c :background ,bg-red-intense)))
        `(symbol-overlay-face-2 ((,c :background ,bg-green-intense)))
        `(symbol-overlay-face-3 ((,c :background ,bg-yellow-intense)))
        `(symbol-overlay-face-4 ((,c :background ,bg-blue-intense)))
        `(symbol-overlay-face-5 ((,c :background ,bg-magenta-intense)))
        `(symbol-overlay-face-6 ((,c :background ,bg-cyan-intense)))
        `(symbol-overlay-face-7 ((,c :background ,bg-red-subtle)))
        `(symbol-overlay-face-8 ((,c :background ,bg-green-subtle))))))
    (defun my/use-ef-themes ()
      (interactive)
      (progn (global-set-key (kbd "C-c t g") 'ef-themes-select)
             (ef-themes-select 'ef-cyprus)))
    (setq ef-themes-disable-other-themes t)
    :config
    (setq ef-themes-mixed-fonts t
          ef-themes-variable-pitch-ui t
          ef-themes-headings '((0 . (variable-pitch 1.61803))
                               (1 . (variable-pitch 1.38196))
                               (2 . (variable-pitch 1.23607))
                               (3 . (variable-pitch 1.1459))
                               (4 . (variable-pitch 1.09017))
                               (5 . (variable-pitch 1.05573))
                               (6 . (variable-pitch 1.03444))
                               (7 . (variable-pitch 1.02129))
                               (t . (variable-pitch 1.0))))
    :hook
    (ef-themes-post-load . my/ef-themes-custom-face))
#+end_src

*** Ligature

#+begin_src emacs-lisp :tangle no
  (use-package ligature
    :ensure t
    :config
    (ligature-set-ligatures
     'prog-mode
     `("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
       "\\\\" "://"
       ("=" ,(rx (one-or-more "=")))
       ("-" ,(rx (one-or-more "-")))
       ("<" ,(rx "<" (one-or-more "-") ">"))))
    (global-ligature-mode t))
#+end_src

#+begin_src emacs-lisp
  (dolist (char/ligature-re
           `((?-  . ,(rx (or (or "-->" "-<<" "->>" "-|" "-~" "-<" "->")
                             (+ "-"))))
             (?/  . ,(rx (or (or "/==" "/=" "/>" "/**" "/*") (+ "/"))))
             (?*  . ,(rx (or (or "*>" "*/") (+ "*"))))
             (?<  . ,(rx (or (or "<<=" "<<-" "<|||" "<==>" "<!--" "<=>" "<||" "<|>" "<-<"
                                 "<==" "<=<" "<-|" "<~>" "<=|" "<~~" "<$>" "<+>" "</>"
                                 "<*>" "<->" "<=" "<|" "<:" "<>"  "<$" "<-" "<~" "<+"
                                 "</" "<*")
                             (+ "<")
                             (+ "-"))))
             (?:  . ,(rx (or (or ":?>" "::=" ":>" ":<" ":?" ":=") (+ ":"))))
             (?=  . ,(rx (or (or "=>>" "==>" "=/=" "=!=" "=>" "=:=") (+ "="))))
             (?!  . ,(rx (or (or "!==" "!=") (+ "!"))))
             (?>  . ,(rx (or (or ">>-" ">>=" ">=>" ">]" ">:" ">-" ">=") (+ ">"))))
             (?&  . ,(rx (+ "&")))
             (?|  . ,(rx (or (or "|->" "|||>" "||>" "|=>" "||-" "||=" "|-" "|>"
                                 "|]" "|}" "|=")
                             (+ "|"))))
             (?.  . ,(rx (or (or ".?" ".=" ".-" "..<") (+ "."))))
             (?+  . ,(rx (or "+>" (+ "+"))))
             (?\[ . ,(rx (or "[<" "[|")))
             (?\{ . ,(rx "{|"))
             (?\? . ,(rx (or (or "?." "?=" "?:") (+ "?"))))
             (?#  . ,(rx (or (or "#_(" "#[" "#{" "#=" "#!" "#:" "#_" "#?" "#(")
                             (+ "#"))))
             (?\; . ,(rx (+ ";")))
             (?_  . ,(rx (or "_|_" "__")))
             (?~  . ,(rx (or "~~>" "~~" "~>" "~-" "~@")))
             (?$  . ,(rx "$>"))
             (?^  . ,(rx "^="))
             (?\] . ,(rx "]#"))))
    (let ((char (car char/ligature-re))
          (ligature-re (cdr char/ligature-re)))
      (set-char-table-range composition-function-table char
                            `([,ligature-re 0 font-shape-gstring]))))
#+end_src

*** nerd-icons :dependency:

Add some fancy icons. Require nerd fonts:

https://www.nerdfonts.com/#home

#+begin_src emacs-lisp
  (use-package nerd-icons :ensure t :demand t)

  (use-package nerd-icons-completion
    :ensure t
    :after marginalia
    :config
    (nerd-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

  (use-package nerd-icons-dired
    :ensure t
    :diminish nerd-icons-dired-mode
    :hook
    (dired-mode . nerd-icons-dired-mode))

  (use-package nerd-icons-corfu
    :ensure t
    :demand t
    :after corfu
    :init
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package nerd-icons-ibuffer
    :ensure t
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

*** logos

#+begin_src emacs-lisp
  (use-package olivetti :defer t
    :ensure t
    :config
    (setq olivetti-body-width 0.618
          olivetti-minimum-body-width 80
          olivetti-recall-visual-line-mode-entry-state t))
  (use-package logos :defer t
    :ensure t
    :config
    (setq logos-outlines-are-pages t)
    (setq-default logos-hide-mode-line nil
                  logos-hide-buffer-boundaries nil
                  logos-hide-fringe t
                  logos-variable-pitch nil
                  logos-buffer-read-only nil
                  logos-scroll-lock t
                  logos-olivetti t)
    (with-eval-after-load 'modus-themes
      (add-hook 'modus-themes-after-load-theme-hook #'logos-update-fringe-in-buffers))
    (with-eval-after-load 'ef-themes
      (add-hook 'ef-themes-post-load-hook #'logos-update-fringe-in-buffers))
    (with-eval-after-load 'standard-themes
      (add-hook 'standard-themes-post-load-hook #'logos-update-fringe-in-buffers))
    :bind
    (("C-c s l" . logos-focus-mode)
     ("C-c s n" . logos-narrow-dwim)
     ("C-c s k" . logos-backward-page-dwim)
     ("C-c s j" . logos-forward-page-dwim)))
#+end_src

*** spacious-padding

#+begin_src emacs-lisp
  ;;; This sample configuration comes from the package's manual

  (use-package spacious-padding
    :ensure (:wait t)
    :config
    (setq spacious-padding-widths
          '( :internal-border-width 16
             :right-divider-width 4
             :mode-line-width 4
             :fringe-width 8)
          spacious-padding-subtle-mode-line
          '( :mode-line-active error
             :mode-line-inactive shadow)))
  (spacious-padding-mode)
#+end_src

*** lin

#+begin_src emacs-lisp
  (use-package lin
    :ensure t
    :init
    (setq lin-face 'lin-green
          lin-mode-hooks '(dired-mode-hook
                           grep-mode-hook
                           ibuffer-mode-hook
                           log-view-mode-hook
                           magit-log-mode-hook
                           occur-mode-hook
                           tabulated-list-mode-hook))
    (lin-global-mode 1))
#+end_src

** COMMENT Completion

*** vertico

Emacs has a tons of variables, commands and documents. When you
exploring them, vertico provides a much more informative interface for
you to browse those information.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure (:wait t)
    :demand t
    :config
    (setq read-extended-command-predicate #'command-completion-default-include-p
          enable-recursive-minibuffers t))
  (vertico-mode)
#+end_src

*** orderless

orderless allows the completion systems using a different completion
strategy. The default completion systems completes based on prefix
matching. orderless enable it to use a fuzzy matching strategy. This
is quite useful because you do not always remember exactly what you
want to search. Sometimes, you do not even know if the things in your
head exist or not, but you want to use the completions system as a
tool to verify your assumption. Orderless completion is really helpful
in these situations.

#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :demand t
    :config
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** marginalia

marginalia works together with vertico, it provides more information
of a variable or function in the completion interface. This may help
you locate your target more quickly.

#+begin_src emacs-lisp
  (use-package marginalia :defer t :ensure (:wait t))
  (marginalia-mode)
#+end_src

*** consult

consult works together with vertico. It helps you complete among lots
of things, such as buffers, file contents, grep results, find results,
etc..

#+begin_src emacs-lisp
  (use-package consult
    :demand t
    :ensure t
    :init
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    (defun consult-ripgrep-with-prefix ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-ripgrep)))
    :config
    (setq consult-fontify-max-size 262144) ;; 262144 = 2 ^ 18
    (setq consult-preview-excluded-files '(".*epub"))

    ;; this handles problems when consult results contains
    ;; Chinese characters
    (if (eq system-type 'windows-nt)
        (progn
          ;; https://github.com/minad/consult/issues/572
          (add-to-list 'process-coding-system-alist
                       '("[rR][gG]" . (utf-8 . gbk-dos)))
          ;; https://github.com/minad/consult/issues/601
          (setq consult-find-args (concat find-program " . "))))
    (with-eval-after-load 'project
      (add-to-list 'project-switch-commands
                   '(consult-project-buffer "Consult buffer" "b"))
      (add-to-list 'project-switch-commands
                   '(consult-fd "Consult fd" "F")))
    :bind
    (([remap switch-to-buffer] . consult-buffer)
     ("C-c i" . consult-line)
     ("C-c r" . consult-ripgrep-with-prefix)
     ("C-c R" . consult-ripgrep)
     ("C-c I" . consult-imenu)
     ("C-c f" . consult-fd)
     ("C-c H" . consult-org-heading)
     ("C-c p" . consult-project-buffer)))
#+end_src

*** embark

embark allows users perform certain tasks in the completion
interface. This reduces the number of operations users have to
perform. For example, when you are trying to delete a certain file,
you have to =find-file= to open the directory the file is located. Then
mark the file to be deleted in dired and finally execute the delete
operation. With embark, you can simply browse to the file in
completion system and then execute =embark-act= then use its delete file
function to delete the current completion candidate. Much more
convenient.

#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :defer t
    :bind ("<f6>" . embark-act))
  (use-package embark-consult :defer t :ensure t)
#+end_src

** COMMENT org-mode

#+begin_src emacs-lisp
  (use-package org :defer t
    :ensure t
    :init
    (defvar my/org-babel-languages (list '(C . t)
                                         '(racket . t)
                                         '(emacs-lisp . t)
                                         '(dot . t)))
    :hook
    (emacs-startup . (lambda ()
                       (org-babel-do-load-languages 'org-babel-load-languages my/org-babel-languages)))
    :config
    (setq org-ellipsis "…"
          org-auto-align-tags nil
          org-tags-column 0
          org-catch-invisible-edits 'show-and-error
          org-special-ctrl-a/e t
          org-hide-emphasis-markers nil
          org-pretty-entities nil
          org-babel-C-compiler "clang"
          org-babel-C++-compiler "clang++"
          ;; org-edit-special will replace the current window with the
          ;; special window
          org-src-window-setup 'current-window)
    (add-to-list 'org-modules 'org-habit t)
    ;; The following code makes org emphasis markup covers more lines
    (setcar (nthcdr 4 org-emphasis-regexp-components) 5)
    (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
    ;; latex preview use dvilualatex and dvisvgm
    (push '(luasvgm
            :programs ("dvilualatex" "dvisvgm")
            :descrition "dvi > svg"
            :message "you need to install the programs: divlualatex dvisvgm"
            :image-input-type "dvi"
            :image-output-type "svg"
            :image-size-adjust (1.7 . 1.5)
            :latex-compiler
            ("dvilualatex -shell-escape -interaction nonstopmode -output-directory %o %f")
            :image-converter
            ("dvisvgm %f --no-fonts --exact-bbox --scale=%S --output=%O"))
          org-preview-latex-process-alist)
    (setq org-preview-latex-default-process 'luasvgm)
    ;; latex export use lualatex
    (setq org-latex-pdf-process '("lualatex -shell-escape -interaction=nonstopmode -output-directory=%o %f")))
#+end_src

*** Exporting Chinese Paragraph to HTML

Due to the difference between English and Chinese, there are some
extra spaces in exported Chinese paragraph when exporting to
HTML. These spaces are necessary since English uses spaces to separate
words, but Chinese don't. We have to override this behavior.

#+begin_src emacs-lisp
  (defadvice org-html-paragraph (before org-html-paragraph-advice
                                        (paragraph contents info) activate)
    "Join consecutive Chinese lines into a single long line without
     unwanted space when exporting org-mode to html."
    (let* ((origin-contents (ad-get-arg 1))
           (fix-regexp "[[:multibyte:]]")
           (fixed-contents
            (replace-regexp-in-string
             (concat
              "\\(" fix-regexp "\\) *\n *\\(" fix-regexp "\\)") "\\1\\2" origin-contents)))
      (ad-set-arg 1 fixed-contents)))
#+end_src

*** COMMENT Show org-agenda Buffer at Start-up

#+begin_src emacs-lisp
  (defun my/get-org-agenda-buffer ()
    (org-agenda-list)
    (get-buffer "*Org Agenda*"))
  (setq initial-buffer-choice #'my/get-org-agenda-buffer)
#+end_src

*** COMMENT capture

#+begin_src emacs-lisp
  (use-package org
               :defer t
               :config
               (setq org-default-notes-file (concat org-directory "/notes.org")))
#+end_src

*** Delete Link

This is inspired by this [[https://emacs.stackexchange.com/a/10714][stackexchange answer]].

#+begin_src emacs-lisp
  (defun my/org-remove-link ()
    "Remove an org link"
    (interactive)
    (if (org-in-regexp org-link-bracket-re 1)
        (save-excursion
          (let ((remove (list (match-beginning 0) (match-end 0))))
            (apply 'delete-region remove)))))
#+end_src

*** Replace Link

This function comes from this [[https://emacs.stackexchange.com/a/10714][stackexchange answer]].

#+begin_src emacs-lisp
  (defun my/org-replace-link-by-link-description ()
    "Replace an org link by its description or if empty its address"
    (interactive)
    (if (org-in-regexp org-link-bracket-re 1)
        (save-excursion
          (let ((remove (list (match-beginning 0) (match-end 0)))
                (description
                 (if (match-end 2)
                     (org-match-string-no-properties 2)
                   (org-match-string-no-properties 1))))
            (apply 'delete-region remove)
            (insert description)))))
#+end_src

*** org-mode Export: htmlize

htmlize is necessary to export code blocks to HTML.

#+begin_src emacs-lisp
  (use-package htmlize :ensure t :defer t)
#+end_src

*** org-mode Appearance: org-modern

org-modern is a package that beautify org-mode. It changes the
appearance of header line, table, time stamp and other things.

#+begin_src emacs-lisp
  (use-package org-modern
    :ensure t
    :defer t
    :hook (org-mode . global-org-modern-mode))
#+end_src

*** org-mode & E-Mail: org-msg

#+begin_src emacs-lisp
  (use-package org-msg :defer t
    :ensure (:wait t)
    :config
    (setq
     org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
     org-msg-startup "hidestars indent inlineimages"
     ;; org-msg-greeting-fmt "\nHi%s,\n\n"
     ;; org-msg-recipient-names '(("jeremy.compostella@gmail.com" . "Jérémy"))
     ;; org-msg-greeting-name-limit 3
     org-msg-default-alternatives '((new		. (text html))
                                    (reply-to-html	. (text html))
                                    (reply-to-text	. (text)))
     org-msg-convert-citation t
     org-msg-signature "

  Regards,

  ,#+begin_signature
  --
  ,*Chang Xiaoduan*
  ,#+end_signature"))

  (org-msg-mode)
#+end_src

*** orin

#+begin_src emacs-lisp
  (use-package orin :defer t
    :ensure (orin
             :type git :host github :repo "drcxd/orin"
             :files ("*.el"))
    :init
    (setq orin-dir "~/org-roam"
          orin-operating-mode 'modern))
#+end_src

** COMMENT Benchmark

Some Emacs users don't care about bootstrap time, they claim that they
only launch Emacs once and never close it until they turn off the
computer. However, I prefer to maintain a reasonable startup
time. It's always a good idea not to pay for what you are not
using.

#+begin_src emacs-lisp
  (use-package benchmark-init
    :ensure t
    :init
    (require 'benchmark-init)
    :hook (after-init . benchmark-init/deactivate))
#+end_src

** COMMENT Windows-Specific

*** powershell

Since I mostly use Emacs on Windows platform, I need this package to
interact nicely with the OS. Emacs built-in eshell mode and term mode
does not work properly on Windows. This package also comes with a
powershell mode to help editing powershell script files.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "init.el" "no")
  (use-package powershell :defer t
    :ensure t)
#+end_src

*** Alert & Notifications

On Linux, Emacs could use D-BUS to send desktop
notifications. However, I could not make dbus work on Windows, so I
found this alert-toast package to implement this feature.

#+begin_src emacs-lisp :tangle (if (eq system-type 'windows-nt) "init.el" "no")
  (if (eq system-type 'windows-nt)
      (use-package alert-toast
        :ensure t
        :after alert
        :config
        (setq alert-default-style 'toast)))
#+end_src

** Window Management

*** zoom

By default, when multiple windows are displayed, Emacs split the
screen evenly among them. However, sometimes, this not what I
like. For example, when I am editing one buffer while reading the
content of another buffer, I may want to make the edited buffer takes
up most of the screen space. Emacs has a series of built-in commands
such as =enlarge-window= which allow users to adjust the window size as
they want. However, this process is repetitive and boring, because it
usually only enlarge/shrink the window by one row/column. zoom helps
me conveniently change the ration of windows sizes by simply execute
one single command.

#+begin_src emacs-lisp
  (use-package zoom
    :defer t
    :ensure t
    :config
    (setq zoom-size '(0.618 . 0.618))
    :bind
    ("C-c z" . zoom)
    ("C-c Z" . zoom-mode))
#+end_src

*** switch-window

#+begin_src emacs-lisp
  (use-package switch-window :ensure t
    :bind
    (("C-c o" . switch-window)
     ("C-c w d" . switch-window-then-delete)
     ("C-c w m" . switch-window-then-maximize)
     ("C-c w s" . switch-window-then-swap-buffer)
     ("C-c w b" . switch-window-then-display-buffer)
     ("C-c w f" . switch-window-then-find-file)
     ([remap other-window] . switch-window)))
#+end_src

** Life Quality

*** ripgrep

ripgrep is a multi-threaded version of grep. It is quite useful when
searching for certain text.

#+begin_src emacs-lisp
  (use-package ripgrep :defer t :ensure t)
#+end_src

*** wgrep

wgrep allows users to modify grep/ripgrep outputs and save the changes
to each output's original location. It is a really powerful
interactive text file editing tool.

#+begin_src emacs-lisp
  (use-package wgrep :defer t :ensure t)
#+end_src

*** scratch

This program allows user to create a scratch buffer of a certain mode,
so you can write anything in it.

#+begin_src emacs-lisp
  (use-package scratch
    :defer t
    :ensure t
    :init
    (defun my/scratch-with-prefix ()
      (interactive)
      (let ((current-prefix-arg '(0)))
        (call-interactively 'scratch)))
    :bind
    ("C-c s c" . my/scratch-with-prefix))
#+end_src

*** Pomodoro and Timers

Sometimes I use the [[https://en.wikipedia.org/wiki/Pomodoro_Technique][pomodoro technique]] to force myself focus on my
task. I have tried [[https://github.com/SqrtMinusOne/pomm.el][pomm]] but I do not like its behavior. It
automatically switch to the next state, while I want to do this
manually. Then I found [[https://github.com/TatriX/pomidor/][pomidor]], this is exactly what I wanted.

Sometimes I just want to set a timer, and I found [[https://github.com/protesilaos/tmr][tmr]]. It's simple and
easy to use.

#+begin_src emacs-lisp
  (use-package tmr
    :defer t
    :ensure t
    :init
    (if (eq system-type 'windows-nt)
        (progn
          (defun my/tmr-alert-notify (timer)
            (let ((title "TMR May Ring")
                  (body (tmr--long-description-for-finished-timer timer)))
              (alert body
                     :title title)))
          (setq tmr-timer-finished-functions (list #'my/tmr-alert-notify
                                                   #'tmr-print-message-for-finished-timer
                                                   #'tmr-acknowledge-minibuffer))))
    :bind
    (("C-c t T" . tmr)
     ("C-c t t" . tmr-with-details)
     ("C-c t r" . tmr-remove-finished)
     ("C-c t R" . tmr-remove)
     ("C-c t l" . tmr-tabulated-view)))

  (use-package pomidor
    :defer t
    :ensure t
    :bind (("C-c t p" . pomidor))
    :config
    (setq
     pomidor-sound-tick nil
     pomidor-sound-tack nil
     pomidor-seconds (* 30 60)
     pomidor-break-seconds (* 10 60)
     pomidor-long-break-seconds (* 25 60))
    (if (eq system-type 'windows-nt)
        (setq pomidor-alert (lambda ()
                              (let ((message (pomidor-default-alert-message)))
                                (when message
                                  (alert message :title "Pomidor")))))))
#+end_src

** Programming

*** Completion

Completion is an important feature of modern IDE. With the help of
language server protocol, Emacs could also provide such service to
programmers.

**** corfu

corfu is a completion front end package. That is, it is responsible to
display the completion candidates on the screen.

#+begin_src emacs-lisp
  (use-package corfu
    :ensure (:wait t)
    :init
    (setq corfu-auto nil
          corfu-cycle t
          corfu-quit-at-boundary nil
          corfu-quit-no-match nil
          corfu-preview-current nil
          corfu-excluded-modes '(gud-mode))
    ;; disalbe corfu in gud-mode, see
    ;; https://github.com/minad/corfu/issues/157 for more detail
    (defun corfu-enable-in-minibuffer ()
      "Enable Corfu in the minibuffer if `completion-at-point' is bound."
      (when (where-is-internal #'completion-at-point (list (current-local-map)))
        (corfu-mode 1)))
    :hook
    (minibuffer-setup . corfu-enable-in-minibuffer)
    :bind
    (:map corfu-map
          ("C-n" . corfu-next)
          ("C-p" . corfu-previous)
          ("<tab>" . corfu-next)
          ("S-<tab>" . corfu-previous)
          ("C-g" . corfu-quit)
          ("<escape>" . corfu-quit)
          ("SPC" . corfu-insert-separator)))

  (unless (display-graphic-p)
    (progn
      (use-package corfu-terminal :defer t)
      (corfu-terminal-mode +1)))

  (global-corfu-mode)
  (corfu-popupinfo-mode)
#+end_src

**** cape

cape provides a set of completion backends. A completion back ends
decides what are the completion candidates.

#+begin_src emacs-lisp
  ;; (use-package company :defer t :ensure t)
  (use-package cape
    :ensure t
    :demand t
    :config
    (add-to-list 'completion-at-point-functions #'cape-abbrev)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    ;; (add-to-list 'completion-at-point-functions #'cape-elisp-block)
    ;; (add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
    (add-to-list 'completion-at-point-functions #'cape-history)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    ;; (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-clang))
    )
#+end_src

*** COMMENT Code Formatting :dependency:

If the code keeps a consistent and easy-to-read format, it will be
much easier to read and maintain. However, manually formatting the
code cannot assure consistency and is also a boring process. We can
use our time to think about more valuable problems. Thus, using a nice
code formatting tool is necessary.

#+begin_src emacs-lisp
  (use-package clang-format :defer t)
  (use-package inheritenv :defer t)
  (use-package language-id :defer t)
  (use-package format-all :defer t)
#+end_src

*** flycheck

flycheck is an error checking package, which displays inline visual
hint for possible code warning or error. Currently, I only use it as
a facility for lsp.

#+begin_src emacs-lisp
  (use-package flycheck :defer t :diminish flycheck-mode :ensure t)
#+end_src

*** hl-todo

This package highlights certain keywords in comments and string
literals.

#+begin_src emacs-lisp
  (use-package hl-todo
    :ensure t
    :defer t
    :config
    (setq hl-todo-highlight-punctuation ":"
          hl-todo-keyword-faces
          `(("TODO" warning bold)
            ("FIXME" error bold)
            ("HACK" font-lock-constant-face bold)
            ("REVIEW" font-lock-keyword-face bold)
            ("NOTE" success bold)
            ("DEPRECATED" font-lock-doc-face bold)
            ("BUG" error bold)))
    :hook
    (prog-mode . hl-todo-mode))
#+end_src

*** git-gutter :dependency:

This packages add visual hint on the fringe to indicate which part of
the file is added/deleted/modified against the latest version in the
version control system.

#+begin_src emacs-lisp
  (use-package git-gutter
    :ensure t
    :diminish git-gutter-mode
    :defer t
    :config
    (setq git-gutter:handled-backends '(git svn))
    :hook
    (prog-mode . git-gutter-mode)
    :bind
    (("C-c v v" . git-gutter)
     ("C-c v n" . git-gutter:next-hunk)
     ("C-c v p" . git-gutter:previous-hunk)
     ("C-c v r" . git-gutter:revert-hunk)))
#+end_src

*** evil-nerd-commenter

Commenting a piece of code might be one of the most frequent
operations a programmer performs. Thus, we need a convenient and smart
package to help us perform this task. evil-nerd-commenter fits my
need.

#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
    :ensure t
    :defer t
    :bind
    (("C-c c" . evilnc-comment-or-uncomment-lines)
     ("C-c C" . evilnc-copy-and-comment-lines)))
#+end_src

*** Symbol Highlighting

When inspecting a piece of code, I need to highlight some of the
symbols to help me quickly locate the places they are referenced.
symbol-overlay is the best package I have known for this task.

#+begin_src emacs-lisp
  (use-package symbol-overlay
    :defer t
    :ensure t
    :bind
    (("C-c s p" . symbol-overlay-put)
     ("C-c s r" . symbol-overlay-remove-all))
    :config
    (setq symbol-overlay-inhibit-map t))
#+end_src

*** Language Server Protocols

Language server protocol is a powerful tool. It enables Eamcs provide
IDE-like functions, such as auto-completion,
jump-to-definition/declaration, find-references and even
variable-rename.

**** lsp-mode :dependency:

#+begin_src emacs-lisp
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))


  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
              (setcar orig-result command-from-exec-path))
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))
  (if (executable-find "emacs-lsp-booster")
      (progn
        (advice-add (if (progn (require 'json)
                               (fboundp 'json-parse-buffer))
                        'json-parse-buffer
                      'json-read)
                    :around
                    #'lsp-booster--advice-json-parse)
        (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)))


#+end_src

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :defer t
    :init
    (defun corfu-lsp-setup ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless))
      (advice-add #'lsp-completion-at-point :around #'cape-wrap-noninterruptible))
    :config
    (setq lsp-headerline-breadcrumb-enable nil
          lsp-semantic-tokens-apply-modifiers nil
          lsp-semantic-tokens-enable t
          lsp-enable-on-type-formatting nil
          read-process-output-max (* 1024 1024)) ;; to increase lsp performance
    (if (and (package-installed-p 'corfu) (package-installed-p 'cape))
        (progn
          (add-hook 'lsp-completion-mode-hook #'corfu-lsp-setup)
          (setq lsp-completion-provider :none)))
    :hook
    (lua-mode . (lambda () (setq-local lsp-enable-indentation nil)))
    (lua-ts-mode . (lambda () (setq-local lsp-enable-indentation nil)))
    :bind
    (("C-c l l" . lsp)
     :map lsp-mode-map
     ("C-c l c" . lsp-find-declaration)
     ("C-c l f" . lsp-find-definition)
     ("C-c l o" . lsp-clangd-find-other-file)
     ("C-c l r" . lsp-workspace-restart)
     ("C-c l d" . lsp-workspace-shutdown)
     ("C-c l a" . lsp-execute-code-action)
     ("C-c l n" . lsp-rename)
     ("C-c l t" . lsp-semantic-tokens-mode)))

  (use-package lsp-ui
    :ensure t
    :defer t
    :bind
    (:map lsp-ui-mode-map
          ("C-c l g" . lsp-ui-doc-glance)
          ("C-c l F" . lsp-ui-doc-focus-frame))
    :config
    (setq lsp-ui-doc-show-with-mouse nil))

  (use-package consult-lsp
    :ensure (:wait t)
    :after (lsp-mode consult)
    :bind
    (:map lsp-mode-map
          ("C-c l S" . consult-lsp-symbols)
          ("C-c l s" . consult-lsp-file-symbols)
          ("C-c l i" . consult-lsp-diagnostics)))

  (with-eval-after-load 'lsp-clangd
    (setq lsp-clients-clangd-args
          '("--completion-style=detailed"
            "--header-insertion=never"
            "--function-arg-placeholders=0"
            "--background-index"
            "--background-index-priority=low"
            "--pch-storage=memory")))

  (add-to-list 'safe-local-eval-forms '(lsp))
#+end_src

***** Python in lsp-mode :dependency:

=lsp-mode= requires a dedicated package -- =lsp-pyright= -- for the
language server =pyright= or =basedpyright=, an open source
alternative for =pyright=.

#+begin_src emacs-lisp
  (use-package lsp-pyright
    :ensure t
    :custom (lsp-pyright-langserver-command "basedpyright"))
#+end_src

**** COMMENT eglot

eglot is the Emacs built-in client for language server
protocol. Generally, its performance is better than lsp-mode, but
lacks several features, e.g., the semantic token highlighting. I have
been using lsp-mode for a long time, but I decide to give eglot a try.

#+begin_src emacs-lisp
  (use-package consult-eglot
    :ensure t
    :defer t)
#+end_src

**** COMMENT lsp-bridge :dependency:

I try lsp-bridge because it works with the language servers
asynchronously, which makes the editing experience more
smooth. However, after testing it, I found it does not integrate with
Emacs as well as lsp-mode. Also, it lacks some of the features I enjoy
in lsp-mode.

#+begin_src emacs-lisp
  ;; Dependencies
  (use-package markdown-mode :defer t :ensure t)
  (use-package yasnippet :defer t :ensure t)

  (use-package lsp-bridge :defer t
    :ensure (lsp-bridge
             :type git :host github :repo "manateelazycat/lsp-bridge"
             :files (:defaults "*.el" "*.py" "acm" "core" "langserver" "multiserver" "resources")
             :build (:not compile))
    :init
    ;; (global-lsp-bridge-mode)
    )
#+end_src

*** COMMENT citre

citre is a package that use tags files to provide IDE-like features
such as completion and jumping to definition. Generally speaking,
solutions based on tags are not as accurate as solutions based on
LSP. However, it is still useful when the project can not be compiled.

#+begin_src emacs-lisp
  (use-package citre :defer t
    :init
    (require 'citre-config))
#+end_src

*** COMMENT Syntax Highlighting

Eamcs has built-in syntax highlighting support, however it is based on
regular expression. This means it would not be correct in every
situation.

lsp also provides syntax highlighting support. This requires a backend
server, and sometimes it is too heavy to practice. What if we are
editing a simple one-file program but still want better syntax
highlighting?

I find the package tree-sitter. Its solution is better than regular
expression but still not a full functional compiler. This means it is
better than the built-in syntax highlighting solution but still not
totally correct. However, it is light-weight enough, so it is still a
viable choice.

After Emacs 29, tree-sitter has been integrated into Emacs core. There
is no need to install these additional packages anymore. Instead,
Emacs need to be compiled with tree-sitter library. Also, users have
to compile language specific shared library themselves to support
specific language major mode.

#+begin_src emacs-lisp :tangle no
  (use-package tree-sitter
   :diminish
   :defer t
   :hook
   ((c-mode . tree-sitter-mode)
    (c++-mode . tree-sitter-mode)
    (lua-mode . tree-sitter-mode)
    (tree-sitter-after-on . tree-sitter-hl-mode)))

  (use-package tree-sitter-langs
   :defer t)
#+end_src

*** Programming Languages

**** C++

#+begin_src emacs-lisp :tangle no
  (defun my/c-indent-then-complete ()
    (interactive)
    (if (= 0 (c-indent-line-or-region))
        (completion-at-point)))
  (with-eval-after-load 'cc-mode
    (define-key c++-mode-map [remap c-indent-line-or-region] 'my/c-indent-then-complete))
#+end_src

**** Lua

Since Emacs provides built-in tree-sitter support, and it provides more accurate analysis than the major mode for Lua, I would use =lua-ts-mode= whenever possible.

#+begin_src emacs-lisp
  (use-package lua-mode :defer t :ensure t)
  ;; (add-to-list 'major-mode-remap-alist '(lua-mode . lua-ts-mode))
#+end_src

**** Scheme

Scheme is a dialect of Lisp. It is also the language used in the book
/Structure and Interpretation of Computer Programs/ (SICP). Emacs
provide nice support for scheme language. It has a built-in package
scheme-mode. The command ~run-scheme~ starts an inferior scheme process
inside Emacs. After that, you can evaluate scheme expression in any
scheme-mode buffer. The expression is evaluated in the inferior scheme
process.

***** Use Scheme in org-mode

To execute scheme code in org-mode, org-babel's [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-scheme.html][document]] requires
[[https://www.nongnu.org/geiser/][Geiser]].

#+begin_src emacs-lisp
  (use-package geiser :defer t :ensure t)
#+end_src

Geiser is an Emacs front end of a Scheme interpreter, and it supports
multiple implementations. For more information about Geiser, check its
documentation in Emacs' INFO pages (after installing the package).

****** A Minor Issue

I was using org 9.5 and I found org-babel failed to execute scheme
code in org-mode buffer. After a simple search, I found one who had
encountered the same
issue. https://www.mail-archive.com/emacs-orgmode@gnu.org/msg142485.html

It turns out there is a bug in org and I have to upgrade it to version
9.6 to fix it.

***** Scheme Implementations

****** COMMENT Chicken :dependency:

The first scheme implementation I used is the [[https://call-cc.org/][chicken
compiler]]. According to its [[https://wiki.call-cc.org/emacs#builtin-scheme-support][documents]], to use it with Emacs built-in
support is easy.

#+begin_src emacs-lisp :tangle no
  (setq scheme-program-name "csi -:c")
#+end_src

However, it needs some additional setup to work with org-babel (see
its [[https://wiki.call-cc.org/emacs#geiser][documents]]). What's more, it does not support Windows platform
nicely. First, there is no pre-built binaries or installers. Though
MSYS2-MinGW 64 package manager could install a package, it is actually
not viable. I have to build the compiler myself. Second,
=chicken-install=, which is a prerequisite for it to work with
org-babel, cannot work correctly on Windows. Chicken requires users to
apply for an account to report bug, which is not convenient.

****** Chez :dependency:

After I have found that I cannot make chicken work with org-babel on
Windows, I switch to [[https://github.com/cisco/ChezScheme][Chez]]. It has nice Windows support, e.g. a Windows
installer. It also host a repository on github so it is easy to report
a bug. Finally, it does not require additional setup to work with
Emacs. The only thing I have to do is to expose its binary =scheme= in
the =PATH=, or customize ~geiser-chez-binary~.

#+begin_src emacs-lisp
  (use-package geiser-chez :defer t :ensure t)
#+end_src

****** COMMENT Racket :dependency:

If I am only using Scheme then Chez is good enough, however, I use
scheme mainly to learn SICP. SICP has some customized code which are
used as dependencies in some exercises. There is a Racket package
(https://docs.racket-lang.org/sicp-manual/index.html
https://github.com/sicp-lang/sicp) that implements these customized
code so that users do not have to input and evaluate them every time
they execute code depends on them. Thus, [[https://racket-lang.org/][Racket]] becomes a better
choice than Chez when learning SICP.

What makes things interesting is that Racket is not only an
implementation of Scheme, but also itself a programming
language. There is a major-mode package =racket-mode= for it. There is
also a specialized org-babel language support package for Racket:
[[https://github.com/hasu/emacs-ob-racket][eamcs-ob-racket]] , which is only available on github. If I want to use
this package, I have no other choice but use =git submodule= to link it
to my configuration repository.

Note that if you want to use =racket-mode= then you should not install
=geiser-racket=. These two packages conflict with each other on some
particular settings. For example, when opening a =.rkt= file, if
=geiser-racket= is installed, then it opens it in =scheme-mode=. This
prevents you use some of the functions provided by =racket-mode=, since
it requires the major mode being =racket-mode=.

Thus, I have to choose one of the two solutions: =geiser-racket= plus
native org-babel support for scheme; or =racket-mode= plus
=emacs-ob-racket=.

I have tried the latter for some time, because I tried to find a way
to use the Racket package for SIPC conveniently in
org-babel. =emacs-ob-racket= allows me to add a header argument to the
code block to declare that the code depends on the SICP package, while
the native support for Scheme language or =geiser-racket= does not
provide such features.

However, =racket-mode= and =eamcs-ob-racket= makes completion when editing
Racket code block difficult, comparing with =geiser-racket=. Actually,
there seems no completion in the org-mode code blocks at all. Thus, I
switch back to =geiser-racket=. This is also because I found that adding
~(require sicp)~ at the beginning of any org-mode Scheme code block
imports the code defined in the SICP package, which is almost equally
convenient as the header argument.

Note that evaluating a Scheme code block in org-mode may be slow. This
can be optimized by having a dedicated REPL for the org-mode
buffer. Thus, org-babel does not have to launch a new instance of
Racket backend each time you evaluate a code block.

#+begin_src emacs-lisp
  (use-package geiser-racket :defer t)
#+end_src

**** Graphviz Dot

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode :defer t
    :ensure t
    :init
    (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot)))
#+end_src

**** Racket

Racket is an implementation of [[Scheme]]. Though there is a package
=geiser-racket= which supports using Racket as the implementation of
scheme, it lacks maintenance now.

With =racket-mode= and =emacs-ob-racket=, I can use Racket as an
implementation of scheme in org mode, though not without troubles.

=racket-mode= requires enable =racket-xp-mode= to provide dynamic
completion. This does not work well with the org mode edit special
buffer. I have to manually execute ~racket-run~ once in a
edit-special-session to make =racket-xp-mode= works. =geiser-racket= is
much more convenient on the completion aspect, though it has severe
problem of correctly executing Racket code.

Thus, I decide to include both solutions in my configuration for now.

#+begin_src emacs-lisp
  (use-package ob-racket :defer t
    :after org
    :config
    (add-hook 'ob-racket-pre-runtime-library-load-hook
              #'ob-racket-raco-make-runtime-library)
    :ensure (ob-racket
             :type git :host github :repo "hasu/emacs-ob-racket"
             :files ("*.el" "*.rkt")))

  (use-package racket-mode :defer t
    :ensure t
    :hook
    (racket-mode . racket-xp-mode))
#+end_src

*** Unreal :dependency:

I am working with Unreal Engine, using Emacs + clangd + lsp-mode as my
development environment. I find that I frequently execute some
operations on my Unreal project, such as generate compilation
database, generate header files, build the project and debug the
project. To accelerate these processes, I have developed the following
routines.

**** Variables

Most of the operations are done using the Unreal Build Tool (UBT). All
operations must be associated with a particular target and
platform. These variables are defined for convenience.

#+begin_src emacs-lisp
  (defvar my/ubt-location nil "Unreal Build Tool file location.")

  (defvar my/unreal-opts '("DebugGame"
                           "Development")
    "A list of frequently used optimization levels for Unreal projects.")

  (defvar my/unreal-platforms '("Win64")
    "A list of frequently used target platforms for Unreal projects.")

  (defun my/build-ubt-op-string (project opt platform &optional editor)
    "Return a string ready to be appended with an UBT operation."
    (let ((name (file-name-base project)))
      (format-message "%s %s %s%s %s %s"
                      my/ubt-location
                      project
                      name
                      (if editor "Editor" "")
                      opt
                      platform)))
#+end_src

**** Build the Project

#+begin_src emacs-lisp
  (defun my/unreal-build-project (project opt platform &optional editor)
    "Build an Unreal project."
    (interactive
     (let ((completion-ignore-case t))
       (list (read-file-name "Project file path: ")
             (completing-read "Optimization level: " my/unreal-opts nil nil)
             (completing-read "Platform: " my/unreal-platforms nil nil)
             current-prefix-arg)))
    (async-shell-command (my/build-ubt-op-string project opt platform editor)))
#+end_src

**** Generating Compilation Database

clangd + lsp-mode requires a compilation database to work. UBT
provides a mode which generates the compilation database.

#+begin_src emacs-lisp
  (defun my/unreal-generate-clang-database (project opt platform &optional editor)
    "Generate compilation database for an Unreal project."
    (interactive
     (let ((completion-ignore-case t))
       (list (read-file-name "Project file path: ")
             (completing-read "Optimization level: " my/unreal-opts nil nil)
             (completing-read "Platform: " my/unreal-platforms nil nil)
             current-prefix-arg)))
    (async-shell-command
     (format-message
      "%s -mode=GenerateClangDatabase"
      (my/build-ubt-op-string project opt platform editor))))

  (defun my/unreal-generate-clang-database-for-engine (opt platform)
    (interactive
     (let ((completion-ignore-case t))
       (list (completing-read "Optimization level: " my/unreal-opts nil nil)
             (completing-read "Platform: " my/unreal-platforms nil nil))))
    (async-shell-command
     (format-message
      "%s -mode=GenerateClangDatabase -Target=UnrealEditor %s %s"
      my/ubt-location opt platform)))
#+end_src

**** Generate Header Files

Unreal Header Tool (UHT) is a program which scans user code and
generate code to implement the reflection code. Its methodology is to
use some macros which expands to file name and line number. Then it
generates code which substitutes those macros. As a result, once the
macro's location has changed, the file will fail the
compilation. However, changing of line number is frequent. This makes
clangd fail to compile the code, thus providing less useful
information when editing. The solution is to generate code every time
some macro's line number has changed.

#+begin_src emacs-lisp
  (defun my/unreal-generate-header-file (project opt platform &optional editor)
    "Generate header files for specified Unreal project."
    (interactive
       (let ((completion-ignore-case t))
         (list (read-file-name "Project file path: ")
               (completing-read "Optimization level: " my/unreal-opts nil nil)
               (completing-read "Platform: " my/unreal-platforms nil nil)
               current-prefix-arg)))
    (async-shell-command
     (format-message
      "%s -SkipBuild"
      (my/build-ubt-op-string project opt platform editor))))
#+end_src

** COMMENT Templates & Snippets

When programming, we have to write some boilerplate code: the
structure of the piece of code is conventional, we only need to
replace some key text in it, for example, the name of the variable.

There is a well-known package for this task: yasnippet. However, this
package is not maintained actively for more than two years (today is
2022-12-10, and its last commit time is 2020-06-04). Thus, I switch to
another package, tempel. Though it is a new package, it has its own
advantages. First, it relies on Emacs built-in Tempo library. Second,
its simple enough to learn and work with. Third, it is maintained
actively. However, since yasnippet is well-known, some other packages,
such as lsp-mode, depends on it somehow, so I still install it.

#+begin_src emacs-lisp
  (use-package tempel :defer t
    :ensure t
    :init
    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
                  (cons #'tempel-expand
                        completion-at-point-functions)))
    :bind
    (("C-c t i" . tempel-insert)
     ("C-c t c" . tempel-complete)
     ("<f7>" . tempel-insert)
     ("<f8>" . tempel-complete))
    :hook
    ((prog-mode . tempel-setup-capf)
     (text-mode . tempel-setup-capf)))

  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :defer t
    :hook
    (prog-mode . yas-minor-mode)
    :bind
    ("C-c Y" . yas-reload-all))
#+end_src

** COMMENT Citation

Currently I am using org-cite, citar plus citeproc to deal with
citation issues.

*** citar

#+begin_src emacs-lisp
  (use-package citar
    :ensure t
    :init
    (setq org-cite-global-bibliography '("~/org-roam/references.bib")
          org-cite-insert-processor 'citar
          org-cite-follow-processor 'citar
          org-cite-activate-processor 'citar
          citar-bibliography org-cite-global-bibliography
          org-cite-export-processors '((t . (csl "modern-language-association.csl"))))
    :hook
    (org-mode . citar-capf-setup))

  (use-package citar-embark
    ;; :defer t
    :ensure t
    :after (citar embark)
    ;; :no-require
    :diminish citar-embark-mode
    :config (citar-embark-mode))

  ;; You can get the csl style files from
  ;; https://github.com/citation-style-language/styles

  ;; (setq org-cite-csl-styles-dir "path/to/styles/dir")
#+end_src

Also, =org-cite-csl-styles-dir= must be set for the csl styles to work.

** COMMENT Taking Notes

As a text editor, Emacs is a good place to take notes. There are also
packages helps you organize your notes. The most popular one is
org-roam. A lighter-weight choice is denote. These two packages are
often used to practice a note-taking methodology called [[https://zettelkasten.de/introduction/][Zettelkasten]].

*** org-roam

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :defer t
    :init
    (setq
     org-roam-database-connector 'sqlite-builtin
     org-roam-directory "~/org-roam/"
     org-roam-node-display-template (concat "${title} " (propertize "${tags}" 'face 'org-tag))
     org-roam-capture-templates '(("d" "default" plain "%?" :target
                                   (file+head "%<%Y%m%d%H%M%S>.org" "#+title: ${title}\n"))
                                  ("p" "private" plain "%?" :target
                                   (file+head "private/%<%Y%m%d%H%M%S>.org" "#+title: ${title}\n")))
     org-roam-dailies-capture-templates '(("d" "default" entry "* %?" :target
                                           (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))
                                          ("p" "private" entry "* %?" :target
                                           (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))

    (defun my/title->file-name (title)
      "Process the input string so that it only contains valid
  characters for file names and is no more than 32 characters."
      (string-limit (replace-regexp-in-string file-name-invalid-regexp "" title) 32))

    (defun my/org-roam-rename-file ()
      "Rename the current org-roam file according to its title field."
      (if (org-roam-buffer-p)
          (let ((title (org-roam-db--file-title))
                (full-name (buffer-file-name)))
            (let ((new-name (format "%s.org" (my/title->file-name title)))
                  (current-name (file-name-nondirectory full-name)))
              (if (not (string= new-name current-name))
                  (if (file-exists-p current-name)
                      (warn (format "File %s already exists. Renaming skipped!" current-name))
                    (if (file-exists-p current-name)
                        (rename-file buffer-file-name new-name))
                    (set-visited-file-name new-name)))))))

    (defun my/org-roam-rename-buffer (&optional buffer)
      "Try to rename the current buffer if it is an org roam buffer and
  has a title. If possible, rename it using both its title and tags."
      (if (org-roam-buffer-p)
          (let ((node (org-roam-node-at-point)))
            (if node
                (let ((tags (org-roam-node-tags node))
                      (title (org-roam-node-title node)))
                  (if title
                      (rename-buffer (format "%s%s"
                                             title
                                             (apply #'concat
                                                    (seq-map (lambda (tag) (format " #%s" tag)) tags)))
                                     t)
                    (let ((title (org-roam-db--file-title)))
                      (if (> (length title) 0)
                          (rename-buffer title t)))))))))

    ;; This is inspired by denote's denote-rename-buffer-mode
    (define-minor-mode org-roam-rename-buffer-file-mode
      "Minor mode rename org mode buffer when opening org roam files,
  creating new org roam nodes, and saving org roam files."
      :global t
      (if org-roam-rename-buffer-file-mode
          (progn
            (add-hook 'org-roam-find-file-hook #'my/org-roam-rename-buffer)
            (add-hook 'org-roam-capture-new-node-hook #'my/org-roam-rename-buffer)
            ;; (add-hook 'before-save-hook #'my/org-roam-rename-file)
            (add-hook 'after-save-hook #'my/org-roam-rename-buffer))
        (remove-hook 'org-roam-find-file-hook #'my/org-roam-rename-buffer)
        (remove-hook 'org-roam-capture-new-node-hook #'my/org-roam-rename-buffer)
        ;; (remove-hook 'before-save-hook #'my/org-roam-rename-file)
        (remove-hook 'after-save-hook #'my/org-roam-rename-buffer)))
    :config
    (org-roam-rename-buffer-file-mode)
    (org-roam-db-autosync-mode)
    :bind
    (("C-c n f" . org-roam-node-find)
     ("C-c n i" . org-roam-node-insert)
     ("C-c n c" . org-roam-capture)
     ("C-c n d" . org-roam-dailies-goto-today)
     ("C-c n D" . org-roam-dailies-goto-date)
     ("C-c n t" . org-roam-tag-add)
     ("C-c n T" . org-roam-tag-remove)
     ("C-c n r" . org-roam-ref-add)
     ("C-c n R" . org-roam-ref-remove)
     ("C-c n b" . org-roam-buffer-toggle)
     ("C-c n B" . org-roam-buffer)
     ("C-c n a" . org-roam-alias-add)
     ("C-c n A" . org-roam-alias-remove)
     ("C-c n y" . org-roam-db-sync)))

  (use-package org-roam-ui :defer t
    :ensure t
    :diminish ((org-roam-ui-mode . "") (org-roam-ui-follow-mode . "")))
#+end_src

**** consult-org-roam

Utility package makes org-roam using consult to search notes, forward
and backward links. It improves the workflow and thus efficiency.

#+begin_src emacs-lisp
  (use-package consult-org-roam
    :ensure t
    :after (org-roam consult)
    :diminish consult-org-roam-mode
    :init
    (setq consult-org-roam-buffer-enabled nil)
    ;; Activate the minor mode
    (consult-org-roam-mode 1)
    :custom
    ;; Use `ripgrep' for searching with `consult-org-roam-search'
    (consult-org-roam-grep-func #'consult-ripgrep)
    ;; Configure a custom narrow key for `consult-buffer'
    (consult-org-roam-buffer-narrow-key ?r)
    ;; Display org-roam buffers right after non-org-roam buffers
    ;; in consult-buffer (and not down at the bottom)
    ;; (consult-org-roam-buffer-after-buffers t)
    :config
    ;; Eventually suppress previewing for certain functions
    ;; (consult-customize
    ;;  consult-org-roam-forward-links
    ;;  :preview-key (kbd "M-."))
    :bind
    ;; Define some convenient keybindings as an addition
    ;; ("C-c n f" . consult-org-roam-file-find)
    ("C-c n l" . consult-org-roam-backlinks)
    ("C-c n L" . consult-org-roam-forward-links)
    ("C-c n s" . consult-org-roam-search))
#+end_src

**** citar-org-roam

A necessary package to integrate citar with org-roam, thus,
bibliographic notes can be easily created in org-roam context.

#+begin_src emacs-lisp
  (use-package citar-org-roam
    :ensure t
    :diminish citar-org-roam-mode
    :after (citar org-roam)
    ;; :no-require
    :config
    (citar-org-roam-mode)
    (add-to-list 'org-roam-capture-templates '("r" "reference" plain "%?" :target
                                               (file+head "%<%Y%m%d%H%M%S>.org" "#+title: ${note-title}\n")
                                               :unnarrowed t) t)
    (setq citar-org-roam-capture-template-key "r"))
#+end_src

*** COMMENT howm

#+begin_src emacs-lisp
  (use-package howm
    :ensure t
    :init
    (require 'howm-org)
    (setq howm-follow-theme t)
    (with-eval-after-load 'meow
      (add-hook 'howm-menu-hook (lambda ()
                                  (if (not meow-motion-mode)
                                      (meow-motion-mode))))))
#+end_src

** COMMENT projectile

Project can be applied to organize anything you are working on. Not
only programming project, but also writing project, note-taking
project, etc.. projectile helps you browse project files, search
contents in project and even run and test project (if it is a
programming project).

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :defer t
    :bind
    (("C-c p f" . projectile-find-file)
     ("C-c p i" . projectile-invalidate-cache)
     ("C-c p s" . (lambda () (interactive) (projectile-switch-project t)))
     ("C-c p d" . projectile-dired)
     ("C-c p r" . projectile-ripgrep))
    :config
    (projectile-global-mode)
    (def-projectile-commander-method ?e "Open eshell at project root." (projectile-run-eshell)))
#+end_src

** COMMENT magit :dependency:

magit is the well-known Emacs interface for git.

#+begin_src emacs-lisp
  (use-package transient :ensure t)
  (use-package magit
    :ensure t
    :defer t
    :init
    ;; Required. But note that this _does_ change Magit's default buffer display behavior.
    (setq magit-display-buffer-function #'display-buffer)
    (add-to-list 'display-buffer-alist
            `((major-mode . magit-status-mode)
              (display-buffer-reuse-window
               display-buffer-in-direction)
              (direction . left)))
    :bind
    ("C-c M" . magit))
#+end_src

** COMMENT Key Binding

*** meow

meow is a modal editing package. It looks like evil, but I think it
suits Emacs more than evil. meow provides supports for many Emacs
packages native key bindings, such as org-mode. For example, when
using meow, you can execute the command =org-babel-tangle= by pressing
=SPC c v t= out-of-the-box, while its original key binding is =C-c C-v
t=. It also works well with my own native key bindings. When using
meow, I do not have to change my original key binding settings. I only
add some additional configuration specific to meow.

#+begin_src emacs-lisp
  (use-package meow
    :ensure t
    :demand t
    :init
    (defun meow-setup ()
      (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
      ;; (meow-motion-overwrite-define-key
      ;;  ;; '("j" . meow-next)
      ;;  ;; '("k" . meow-prev)
      ;;  '("<escape>" . ignore))
      (meow-leader-define-key
       ;; SPC j/k will run the original command in MOTION state.
       ;; '("j" . "H-j")
       ;; '("k" . "H-k")
       ;; Use SPC (0-9) for digit arguments.
       '("1" . meow-digit-argument)
       '("2" . meow-digit-argument)
       '("3" . meow-digit-argument)
       '("4" . meow-digit-argument)
       '("5" . meow-digit-argument)
       '("6" . meow-digit-argument)
       '("7" . meow-digit-argument)
       '("8" . meow-digit-argument)
       '("9" . meow-digit-argument)
       '("0" . meow-digit-argument)
       '("/" . meow-keypad-describe-key)
       '("?" . meow-cheatsheet))
      (meow-normal-define-key
       '("0" . meow-expand-0)
       '("9" . meow-expand-9)
       '("8" . meow-expand-8)
       '("7" . meow-expand-7)
       '("6" . meow-expand-6)
       '("5" . meow-expand-5)
       '("4" . meow-expand-4)
       '("3" . meow-expand-3)
       '("2" . meow-expand-2)
       '("1" . meow-expand-1)
       '("-" . negative-argument)
       '(";" . meow-reverse)
       '("," . meow-inner-of-thing)
       '("." . meow-bounds-of-thing)
       '("[" . meow-beginning-of-thing)
       '("]" . meow-end-of-thing)
       '("a" . meow-append)
       '("A" . meow-open-below)
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("c" . meow-change)
       '("d" . meow-delete)
       '("D" . meow-backward-delete)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("f" . meow-find)
       ;; `fill-region' is assigned to F in normal mode because I
       ;; usually select region in normal mode.
       '("F" . fill-region)
       '("g" . meow-cancel-selection)
       '("G" . meow-grab)
       '("h" . meow-block)
       '("H" . meow-to-block)
       '("i" . meow-prev)
       '("I" . meow-prev-expand)
       '("j" . meow-left)
       '("J" . meow-left-expand)
       '("k" . meow-next)
       '("K" . meow-next-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '("m" . meow-join)
       '("M" . magit)
       '("n" . meow-search)
       '("o" . meow-insert)
       '("O" . meow-open-above)
       '("p" . meow-yank)
       '("P" . meow-yank-pop)
       '("q" . evilnc-comment-or-uncomment-lines)
       '("Q" . evilnc-copy-and-comment-lines)
       '("r" . meow-replace)
       '("R" . meow-swap-grab)
       '("s" . meow-kill)
       '("S" . shell-command)
       '("t" . meow-till)
       '("u" . meow-undo)
       '("U" . meow-undo-in-selection)
       '("v" . meow-visit)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("x" . meow-line)
       '("X" . meow-goto-line)
       '("y" . meow-save)
       '("Y" . meow-sync-grab)
       '("z" . meow-pop-selection)
       '("'" . repeat)
       '("<escape>" . ignore)
       '("=" . indent-region)
       '("`" . delete-horizontal-space)
       '("{" . backward-paragraph)
       '("}" . forward-paragraph)
       '("/" . hs-toggle-hiding))
      ;; disable SPC in motion mode since it might be used
      (define-key meow-motion-state-keymap (kbd "SPC") nil))
    :config
    (setq meow-replace-state-name-list '((normal . "[N]")
                                         (motion . "[M]")
                                         (keypad . "[K]")
                                         (insert . "[I]")
                                         (beacon . "[B]"))
          meow-keypad-leader-dispatch "C-c"
          meow-mode-state-list '((fundamental-mode . normal)
                                 (text-mode . normal)
                                 (prog-mode . normal)
                                 (conf-mode . normal)
                                 (bibtex-mode . normal))
          meow-use-clipboard t
          meow-keypad-describe-keymap-function nil)
    ;; use motion state by default
    (defun my/meow-guess-state (state) 'motion)
    (advice-add 'meow--mode-guess-state :filter-return #'my/meow-guess-state)
    (meow-setup)
    (meow-global-mode 1)
    (global-set-key (kbd "<f5>") 'meow-keypad)
    :hook
    (meow-insert-exit . (lambda ()
                          (if (and meow-normal-mode (not buffer-read-only))
                              (delete-trailing-whitespace (pos-bol) (pos-eol))))))
#+end_src

**** A Note About KEYPAD Mode

Meow's default behavior is to add =C-`= prefix to any key with no
prefix. This looks counter-intuitive to me. Meow is trying to simulate
Emacs native key bindings, but this behavior is the contrary of Emacs
native style. For example, command =view-echo-area-message= is bound to
=C-h e=, and command =view-external-packages= is bound to =C-h
C-e=. Translated into Meow, =view-echo-area-message= is bound to =SPC h
SPC e=, while =view-external-packages= is bound to =SPC h
e=. =view-external-packages= has more key strokes in native key bindings,
but has less key stokes in Meow. =view-echo-area-message= has less key
strokes in native key bindings, but has more key strokes in Meow.

Also, Meow has a fallback mechanism. Meow maps =C-h k= to =SPC h SPC k=,
and =C-h C-k= to =SPC h k=. However, when =C-h C-k= is unbound, =SPC h k= will
automatically invokes the command bound to =C-h k=. This is convenient,
but it introduces uncertainty. Meow users could not know the command
=SPC h k= invokes is bound to which native key binding: =C-h C-k= or =C-h
k=.

The author's explanation for this behavior is [[https://github.com/meow-edit/meow/issues/47#issuecomment-1377206836][here]]. I try to
understand and accept the author's idea, but I still found that if
KEYPAD does not automatically add =C-= prefix would be better. I have
asked the author to add an option to let users make their own choices,
but the author seems not agree with me.

Thus, I tried to dig into the source code and modify them by
myself. In =meow-keypad.el=, there is a function
=meow-keypad-self-insert=, which defines how KEYPAD translate key
strokes. If we exchange the code dealing with literal and non-prefix
cases, then we change KEYPAD's behavior to not automatically add =C-=
prefix, but only when =SPC= is pressed. This modification introduces a
new problem: which-key prompt for KEYPAD key bindings does not update
to fit this change. There are two additional functions
=meow--keypad-format-keys= and =meow--keypad-get-keymap-for-describe=, they all
have similar structures to that of =meow-keypad-self-insert=, deal with
them so that Meow generate the correct hints.

*** COMMENT which-key

With so many key bindings, it is impossible to memorize all of
them. which-key is a package that displays all viable commands and
their key bindings when you are in the middle of a sequence of key
binding.

#+begin_src emacs-lisp
  (use-package which-key
   :diminish
   :config
   (which-key-mode))
#+end_src

** COMMENT EBooks

*** calibre Interface

**** COMMENT calibredb

#+begin_src emacs-lisp
  (use-package calibredb
    :defer t)
#+end_src

To use this package, several other variables have to be set:

- =calibredb-root-dir=
- =calibredb-db-dir=
- =calibredb-program=
- =calibredb-library-alist=


However, the values of these variables depends on the actual location
of the calibre libraries on the current computer. Thus, it is better
to put these configurations in the local =custom.el= file.

**** calibre

This is an alternative to calibredb. I prefer this package over
calibredb. I have added some custom functions to open the directory
that contains a book in Dired.

#+begin_src emacs-lisp
  (use-package calibre :defer t :ensure t)
    ;; :config
    ;; (use-package calibre-library
    ;;   :ensure nil
    ;;   :config
    ;;   (defun calibre-book--path (book)
    ;;     "Return the path to the directory of BOOK."
    ;;     (let ((path (calibre-book-path book)))
    ;;       (file-name-concat (calibre--library)
    ;;                         path)))
    ;;   (defun calibre-library-open-book-dir (book)
    ;;     "Open the directory of BOOK."
    ;;     (interactive (list (tabulated-list-get-id))
    ;;                  calibre-library-mode)
    ;;     (find-file (calibre-book--path book)))
    ;;   :bind
    ;;   (:map calibre-library-mode-map
    ;;         ("O" . calibre-library-open-book-dir))))
#+end_src

This package also requires some local settings, for example, we have
to specify the location of the library:

#+begin_src emacs-lisp :tangle no
  (setq calibre-libraries '(("nonficition" . "~/Documents/Non Fiction Library/")))
#+end_src

Also, we can specify an external program to open a certain format of a book:

#+begin_src emacs-lisp :tangle no
  (setq calibre-external-programs '((pdf . "acrobat")))
#+end_src

Otherwise, the book is opened inside Emacs.

*** nov

nov is a package that allows you read EPUB files inside Emacs.

#+begin_src emacs-lisp
  (use-package nov
    :ensure t
    :defer t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    (setq nov-text-width t)
    :hook
    (nov-mode . (lambda () (setq truncate-lines nil))))
#+end_src

** COMMENT Typst :dependency:

Typst is a new markup language for typesetting document. The following
packages provides support for writing Typst document in Emacs.

#+begin_src emacs-lisp
  ;; tree sitter mode Typst
  (use-package typst-ts-mode :defer t
    :ensure (:type git :host codeberg :repo "meow_king/typst-ts-mode")
    :init
    (add-to-list 'org-src-lang-modes '("typst" . typst-ts)))

  ;; typst-preview provides live preview for Typst documents
  (use-package typst-preview :defer t
    :after websocket ;; typst-preview require websocket
    :ensure (:type git :host github :repo "drcxd/typst-preview.el"))

  (use-package org-typst-preview :defer t
    :after org
    :ensure (:type git :host github :repo "drcxd/org-typst-preview.el")
    :bind
    (("C-c t y" . org-typst-preview)
     ("C-c t b" . org-typst-preview-render-buffer)
     ("C-c t B" . org-typst-preview-clear-buffer)))

  (use-package ox-typst :after org :ensure t)
#+end_src

** COMMENT Filling and Wrapping

~visual-line-fill-column-mode~ is useful when writing Chinese prose or
scientific prose which contains mathematics symbols, but there is no
good using it when writing English prose. Since using this mode mainly
requires you write very long lines, it would make reading the =diff=
between versions really difficult. Also, it destroys code blocks in
=org-mode=, so I decide to not automatically enable it from now on.

#+begin_src emacs-lisp
  (use-package visual-fill-column :defer t
    :ensure t
    :bind
    ("C-c v f" . visual-line-fill-column-mode))
  (use-package unfill :defer t :ensure t)
#+end_src

** COMMENT Transient

A tutorial about using transient. I tried to use transient to develop
a menu for my day-to-day workflow, but its manual is not intuitive for
me, so the idea has been infinitely delayed. Maybe someday I can use
this tutorial.

https://cocode.se/emacs/transient_cont.html

** COMMENT elfeed

I used to collect interesting blogs in my personal notes. However, the
problem is that I  always forget to revisit them unless I encounter
something reminds me of them. Now I learned that RSS feed solves my
problem perfectly, and I am going to use elfeed for it. Gnus may do
the same work, but elfeed seems more dedicated and easy to use.

#+begin_src emacs-lisp
  (use-package elfeed :defer t :ensure t
    :init
    (setq elfeed-feeds '("https://www.filfre.net/feed/rss/"
                         "https://hsu.cy/feed.xml"
                         "https://hnrss.org/bestcomments/")
          elfeed-search-filter "@1-month-ago +unread"))
#+end_src

** COMMENT foma

#+begin_src emacs-lisp
  (use-package foma
    :ensure (foma :type git :host github :repo "drcxd/foma" :files ("*.el")))

  (setq foma-default-variable-pitch-font "Clear Sans"
        foma-default-weight 'regular
        foma-default-height 128
        foma-fonts '(("Cascadia Code" zip "https://github.com/microsoft/cascadia-code/releases/download/v2407.24/CascadiaCode-2407.24.zip")
                     ("Victor Mono" zip "https://rubjo.github.io/victor-mono/VictorMonoAll.zip")
                     ("Aporetic" zip "https://github.com/protesilaos/aporetic/archive/refs/heads/main.zip")
                     ("IBM Plex Sans" zip "https://github.com/IBM/plex/releases/download/%40ibm%2Fplex-sans%401.1.0/ibm-plex-sans.zip")
                     ("IBM Plex Mono" zip "https://github.com/IBM/plex/releases/download/%40ibm%2Fplex-mono%401.1.0/ibm-plex-mono.zip")
                     ("JetBrains Mono" zip "https://download.jetbrains.com/fonts/JetBrainsMono-2.304.zip")
                     ("Red Hat" zip "https://github.com/RedHatOfficial/RedHatFont/archive/refs/heads/master.zip")
                     ("Source Code Pro" zip "https://github.com/adobe-fonts/source-code-pro/releases/download/2.042R-u%2F1.062R-i%2F1.026R-vf/TTF-source-code-pro-2.042R-u_1.062R-i.zip")
                     ("Source Sans" zip "https://github.com/adobe-fonts/source-sans/releases/download/3.052R/TTF-source-sans-3.052R.zip")
                     ("Intel One Mono" zip "https://github.com/intel/intel-one-mono/releases/download/V1.4.0/ttf.zip")
                     ("Clear Sans" zip "https://github.com/intel/clear-sans/archive/refs/heads/main.zip")
                     ("DejaVu" zip "https://github.com/dejavu-fonts/dejavu-fonts/releases/download/version_2_37/dejavu-fonts-ttf-2.37.zip")
                     ("JuliaMono" zip "https://github.com/cormullion/juliamono/releases/download/v0.059/JuliaMono-ttf.zip")
                     ("Nerd Icons" zip "https://github.com/ryanoasis/nerd-fonts/releases/download/v3.3.0/NerdFontsSymbolsOnly.zip")
                     ("LXGW WenKai" zip "https://github.com/lxgw/LxgwWenKai/releases/download/v1.510/lxgw-wenkai-v1.510.zip")
                     ("Noto Sans" google)
                     ("Noto Sans Mono" google))
        foma-profiles `(("Aporetic" "Aporetic Sans Mono" "Aporetic Sans")
                        ("Cascadia" "Cascadia Code")
                        ("DejaVu" "DejaVu Sans Mono" "DejaVu Sans")
                        ("IBM" "IBM Plex Mono" "IBM Plex Sans")
                        ("Intel" "Intel One Mono" "Clear Sans")
                        ("JetBrains" "JetBrains Mono")
                        ("Julia" "JuliaMono")
                        ("Noto" "Noto Sans Mono" "Noto Sans")
                        ("Red Hat" "Red Hat Mono" "Red Hat Text")
                        ("Source" "Source Code Pro" "Source Sans Pro")
                        ("Victor" "Victor Mono")))
#+end_src

** Finalizing

#+begin_src emacs-lisp
  ;; wait for elpaca until all packages are installed since some code in
  ;; the custom file may depend on some packages
  (elpaca-wait)
#+end_src

* Keyboard Macros

Since keyboard macros may depends on built-in or third party packages,
I put them here.

To add new keyboard macros, first name the keyboard macros with
~kmacro-name-last-macro~, then insert its definition with
~insert-kbd-macro~.

#+begin_src emacs-lisp
  (defalias 'my/default-window-layout
     (kmacro "C-x 1 C-x 3 C-x o C-x 2 C-x o 3 C-c z"))
#+end_src

* Load Custom File

Finally, after all the other settings have been done, we load the
local customization file.

#+begin_src emacs-lisp
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src
