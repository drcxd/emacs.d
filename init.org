#+property: header-args:emacs-lisp :tangle init.el :comments org

* Abstract

Trying literate programming with my emacs configuration. This is
inspired by http://alhassy.com/emacs.d/.

* TODO Garbage Collection Settings

Adjust garbage collection thresholds during startup, and
thereafter. This piece of code only works with lexical binding. I have
not figured out how to enable it in the tangled file.

#+begin_src emacs-lisp :lexical t :tangle no
  (let ((normal-gc-cons-threshold (* 20 1024 1024))
        (init-gc-cons-threshold (* 128 1024 1024)))
    (setq gc-cons-threshold init-gc-cons-threshold)
    (add-hook 'emacs-startup-hook
              (lambda () (setq gc-cons-threshold normal-gc-cons-threshold))))
#+end_src

* Package

Since I am currently located in China, sometimes the connection to
melpa is not stable. As a result, I have to use lcoal package archive
repository or some mirror sites.

#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives
        '(
          ("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ;; ("melpa-stable" . "https://stable.melpa.org/packages/")
          ("nongnu" . "https://elpa.nongnu.org/nongnu/")

          ;; use local repository
          ;; ("local-melpa" . "~/elpa-mirror-master/melpa/")
          ;; ("local-gnu" . "~/elpa-mirror-master/gnu/")
          ;; ("local-nongnu" . "~/elpa-mirror-master/nongnu/")

          ;; Use either 163 or tsinghua mirror repository when official melpa
          ;; is slow or shutdown.

          ;; ;; {{ Option 1: 163 mirror repository:
          ;; ("gnu" . "https://mirrors.163.com/elpa/gnu/")
          ;; ("melpa" . "https://mirrors.163.com/elpa/melpa/")
          ;; ("melpa-stable" . "https://mirrors.163.com/elpa/stable-melpa/")
          ;; ("nongnu" . "https://mirrors.163.com/elpa/nongnu/")
          ;; ;; }}

          ;; ;; {{ Option 2: tsinghua mirror repository
          ;; ;; @see https://mirror.tuna.tsinghua.edu.cn/help/elpa/ on usage:
          ;; ;; ("gnu"   . "http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
          ;; ("melpa" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/")
          ;; ("melpa-stable" . "http://mirrors.tuna.tsinghua.edu.cn/elpa/stable-melpa/")
          ;; }}

          ;; gitlab mirror
          ;; ("melpa" . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/melpa/")
          ;; ("org"   . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/org/")
          ;; ("gnu"   . "https://gitlab.com/d12frosted/elpa-mirror/raw/master/gnu/")
          ))
  ;; (package-refresh-contents)
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

* Benchmark

Some Emacs users don't care about bootstrap time, they claim that they
only launch emacs once and never close it until they turn off the
computer. However, I prefer to maintain a reasonable startup
time. It's always a good idea not to pay for what you are not
using.

#+begin_src emacs-lisp
  (use-package benchmark-init
               :init
               (require 'benchmark-init)
               :hook (after-init . benchmark-init/deactivate))
#+end_src

* Who am I?

#+begin_src emacs-lisp
  (setq user-full-name "Chang Xiaoduan"
        user-mail-address "drcxd@sina.com")
#+end_src

* Custom File Location

It is good to place the custom file in =.emacs.d= directory. This way,
we have all the files related to Emacs in one single directory.

#+begin_src emacs-lisp
  (setq custom-file (locate-user-emacs-file "custom.el"))
#+end_src

* Diminish

I am using the built-in modeline, and it displays a symbol for all the
activated minor modes. This could makes the modeline messy, because
usually we have lots of minor modes turned on but we do not need the
visual cue on the modeline to tell us they are enabled. Diminish is a
good package to solve this problem.

#+begin_src emacs-lisp
  (use-package
    :demand t
    diminish
    :config
    (diminish 'abbrev-mode)
    (diminish 'visual-line-mode)
    (diminish 'eldoc-mode)
    :hook
    ((hs-minor-mode . (lambda () (diminish 'hs-minor-mode)))
     (olivetti-mode . (lambda () (diminish 'olivetti-mode)))
     (logos-focus-mode . (lambda () (diminish 'buffer-face-mode)))
     (yas-minor-mode . (lambda () (diminish 'yas-minor-mode)))
     (org-roam-ui-mode . (lambda () (diminish 'org-roam-ui-mode)))
     (org-roam-ui-follow-mode . (lambda () (diminish 'org-roam-ui-follow-mode)))))
#+end_src

* Appearance

** Frame Settings

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html][Frame parameters]] can be used to control the appearance of Emacs
frame. We can use these parameters to hide menu bar, adjust frame's
position and width, etc..

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** Uniquify

When two buffers of the same name are opened, Emacs has to uniquify
them so you can distinguish between them.

#+begin_src emacs-lisp
  (require 'uniquify)

  (setq uniquify-buffer-name-style 'reverse)
  (setq uniquify-separator " • ")
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-ignore-buffers-re "^\\*")
#+end_src

** ibuffer

ibuffer is a buffer list all opened buffers in Emacs. You can use it
to manage these buffers just as you manage files in dired.

#+begin_src emacs-lisp
  (with-eval-after-load 'ibuffer
    ;; Use human readable Size column instead of original one
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000)
        (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000)
        (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t
        (format "%8d" (buffer-size)))))

    (setq ibuffer-expert t
          ibuffer-show-empty-filter-groups nil
          ibuffer-display-summary nil)

    (setq ibuffer-saved-filter-groups
          (quote (("default"
                   ("code" (or (mode . emacs-lisp-mode)
                               (mode . cperl-mode)
                               (mode . c-mode)
                               (mode . java-mode)
                               (mode . idl-mode)
                               (mode . web-mode)
                               (mode . lisp-mode)
                               (mode . js2-mode)
                               (mode . c++-mode)
                               (mode . lua-mode)
                               (mode . cmake-mode)
                               (mode . ruby-mode)
                               (mode . css-mode)
                               (mode . objc-mode)
                               (mode . sql-mode)
                               (mode . python-mode)
                               (mode . php-mode)
                               (mode . sh-mode)
                               (mode . json-mode)
                               (mode . scala-mode)
                               (mode . go-mode)
                               (mode . erlang-mode)))

                   ("dired" (or (mode . dired-mode)
                                (mode . sr-mode)))

                   ("erc" (mode . erc-mode))

                   ("planner" (or (name . "^\\*Calendar\\*$")
                                  (name . "^diary$")
                                  (mode . muse-mode)
                                  (mode . org-mode)
                                  (mode . org-agenda-mode)))

                   ("emacs" (or (name . "^\\*scratch\\*$")
                                (name . "^\\*Messages\\*$")))

                   ("gnus" (or (mode . message-mode)
                               (mode . bbdb-mode)
                               (mode . mail-mode)
                               (mode . gnus-group-mode)
                               (mode . gnus-summary-mode)
                               (mode . gnus-article-mode)
                               (name . "^\\.bbdb$")
                               (name . "^\\.newsrc-dribble")))))))
    (defun ibuffer-mode-hook-setup ()
      (unless (eq ibuffer-sorting-mode 'filename/process)
        (ibuffer-do-sort-by-filename/process))
      (ibuffer-switch-to-saved-filter-groups "default"))

    (add-hook 'ibuffer-mode-hook 'ibuffer-mode-hook-setup)

    ;; Modify the default ibuffer-formats
    (setq ibuffer-formats
          '((mark modified read-only " "
                  (name 18 18 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  filename-and-process)))

    (setq ibuffer-filter-group-name-face 'font-lock-doc-face))

  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

** Unicode Support

#+begin_src emacs-lisp
  (use-package
   unicode-fonts
   :config
   (unicode-fonts-setup))
#+end_src

** Fonts and Faces :DEPENDENCY:

#+begin_src emacs-lisp
  (set-fontset-font "fontset-default" 'han "Microsoft Yahei")

  (set-face-attribute 'default nil
                      :font "Iosevka Comfy"
                      :height 160)
  (set-face-attribute 'fixed-pitch nil
                      :font "Iosevka Comfy"
                      :height 1.0)
  (set-face-attribute 'variable-pitch nil
                      :font "Iosevka Comfy Duo"
                      :height 1.0)

  ;; italic
  (set-face-attribute 'italic nil
                      :slant 'italic
                      :underline nil)
#+end_src

** Themes

#+begin_src emacs-lisp
  (use-package
    modus-themes
    :demand t
    :init
    (defun my-use-modus-themes ()
      (interactive)
      (load-theme 'modus-operandi :no-confirm)
      (my-custom-set-face)
      (global-set-key (kbd "C-c tg") 'modus-themes-select))
    (defun my-custom-set-face ()
      (modus-themes-with-colors
        (custom-set-faces
         `(lsp-ui-doc-background ((,c :background ,bg-dim))))))
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs nil
          modus-themes-mixed-fonts t
          modus-themes-variable-pitch-ui t
          modus-themes-mode-line '(borderless)
          modus-themes-headings '((0 . (variable-pitch 1.61803))
                                  (1 . (variable-pitch 1.38196))
                                  (2 . (variable-pitch 1.23607))
                                  (3 . (variable-pitch 1.1459))
                                  (4 . (variable-pitch 1.09017))
                                  (5 . (variable-pitch 1.05573))
                                  (6 . (variable-pitch 1.03444))
                                  (7 . (variable-pitch 1.02129))
                                  (t . (variable-pitch 1.0))))
    :hook
    (modus-themes-after-load-theme . my-custom-set-face))

  ;; (use-package
  ;;   ef-themes
  ;;   :defer t
  ;;   :init
  ;;   (defun my-ef-themes-custom-faces ()
  ;;     "My customizations on top of Ef themes.
  ;; This function is added to the `ef-themes-post-load-hook'."
  ;;     (ef-themes-with-colors
  ;;      (custom-set-faces
  ;;       `(lsp-ui-doc-background ((,c :background ,bg-alt))))))
  ;;   (defun my-use-ef-themes ()
  ;;     (interactive)
  ;;     (mapc #'disable-theme custom-enabled-themes)
  ;;     (ef-themes-select 'ef-light)
  ;;     (global-set-key (kbd "C-c tg") 'ef-themes-toggle)
  ;;     )
  ;;   :config
  ;;   (setq
  ;;    ef-themes-to-toggle '(ef-light ef-dark)
  ;;    ef-themes-mixed-fonts t
  ;;    ef-themes-variable-pitch-ui t)
  ;;   (with-eval-after-load 'tree-sitter
  ;;     (add-hook 'tree-sitter-hl-mode-hook
  ;;               (lambda () (set-face-attribute
  ;;                           'tree-sitter-hl-face:punctuation
  ;;                           nil
  ;;                           :inherit nil))))
  ;;   :hook
  ;;   (ef-themes-post-load-hook . my-ef-themes-custom-faces))

  ;; (use-package
  ;;   standard-themes
  ;;   :defer t
  ;;   :init
  ;;   (defun my-use-standard-themes ()
  ;;     (interactive)
  ;;     (mapc #'disable-theme custom-enabled-themes)
  ;;     (load-theme 'standard-light :no-confirm)
  ;;     (global-set-key (kbd "C-c tg") 'standard-themes-toggle))
  ;;   :config
  ;;   (setq standard-themes-bold-constructs t
  ;;         standard-themes-italic-constructs t
  ;;         standard-themes-mixed-fonts t
  ;;         standard-themes-variable-pitch-ui t
  ;;         standard-themes-fringes 'subtle))

  ;; (my-use-ef-themes)
  (my-use-modus-themes)
  ;; (my-use-standard-themes)
#+end_src

** Ligature

#+begin_src emacs-lisp
  (use-package
   ligature
   :config
   (ligature-set-ligatures
    'prog-mode
    `("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
      ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
      "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
      "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
      "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
      "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
      "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
      "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
      ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
      "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
      "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
      "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
      "\\\\" "://" ("=" ,(rx (+ "=")))))
   (global-ligature-mode t))
#+end_src

** modeline

#+begin_src emacs-lisp
  (setq display-time-24hr-format t)
  (display-time)
  (column-number-mode)
#+end_src

** logos

#+begin_src emacs-lisp
  (use-package olivetti :defer t :diminish)
  (use-package
    logos
    :diminish
    :defer t
    :config
    (setq logos-outlines-are-pages t)
    (setq-default logos-hide-mode-line nil
                  logos-hide-buffer-boundaries nil
                  logos-hide-fringe t
                  logos-variable-pitch t
                  logos-buffer-read-only nil
                  logos-olivetti t)
    (with-eval-after-load 'modus-themes
      (add-hook 'modus-themes-after-load-theme-hook #'logos-update-fringe-in-buffers))
    (with-eval-after-load 'ef-themes
      (add-hook 'ef-themes-post-load-hook #'logos-update-fringe-in-buffers))
    :bind
    (("C-c s l" . logos-focus-mode)
     ("C-c s n" . logos-narrow-dwim)
     ("C-c s k" . logos-backward-page-dwim)
     ("C-c s j" . logos-forward-page-dwim)))
#+end_src

* General Behavior

** Auto Backup

By default, Emacs will automatically generate a backup file every time
you edit an existing file. If your file name is =fname.txt=, then it
generates a backup file named =fname.txt=. This can quickly make the
directory messy, so I prefer disable this feature.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
#+end_src

** Splash Screen

By default, Emacs shows a welcome screen every time it is
launched. This might be useful to new Emacs users, but for experienced
users, displaying the =*scratch*= buffer by default may be more
productive. You could also execute the command =about-emacs= to display
the splash screen manually.

#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
#+end_src

** Auto Save

Emacs can automatically save edited files after some certain idle
time. This feature is disabled by default. I would like to enable it
to prevent accidental loss of data. The idle time should not be too
short since this would incur frequently disk I/O.

Note: I found that changing the value of ~auto-save-visited-interval~
does not change the behavior of Emacs. This might be a
platform-specific bug.

#+begin_src emacs-lisp
  (auto-save-visited-mode 1)
  (setq auto-save-visited-interval 5)
#+end_src

** Auto Revert

I turn on auto-revert-mode because sometimes when a file is edited by
some external programs, edit it again and save it in Emacs will
confict with the external changes. Enable auto-revert-mode eliminate
the chances of such problems.

#+begin_src emacs-lisp
  (global-auto-revert-mode)
  (setq auto-revert-verbose nil)
#+end_src

** No Tab Character

Tab could be translated to different length spaces by different
editors. To avoid such a difference, simply avoid using tab.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Recent Files

It would be convenient to quickly open the file you have edited in
your last Emacs session. With recentf-mode, you do not have to input
the location of the file every time you visit it, but choose from a
maintained recent file list.

#+begin_src emacs-lisp
  (recentf-mode 1)
#+end_src

** Dired

dired is the facility Emacs uses to manage directories, its like the
file explorer of an operating system, you can perform any file related
operations in dired.

#+begin_src emacs-lisp
  (setq dired-kill-when-opening-new-dired-buffer t)
  (defun dired-mode-setup ()
    "Setup dired."
    (dired-hide-details-mode 1)
    ;; global-auto-revert-mode does not work for dired
    (auto-revert-mode)
    (hl-line-mode 1))
  (add-hook 'dired-mode-hook 'dired-mode-setup)
  (with-eval-after-load 'dired
    (require 'dired-x))
#+end_src

** Mottoes

I would like the welcome message displayed in the scratch buffer be
some mottoes selected randomly from a pre-defined list.

#+begin_src emacs-lisp
  (defun my/process-raw-mottoes (lines)
    "Process motto strings so that they could be displayed in the
  scratch buffer."
    (let ((ret ""))
      (dolist (line lines ret)
        (setq ret (concat ret ";; " line "\n")))))

  (defvar my/raw-mottoes
    '(("困于心衡于虑而后作" "征于色发于声而后喻")
      ("学而不思则罔" "思而不学则殆")
      ("生于忧患" "死于安乐")
      ("天生我材必有用" "千金散尽还复来")
      ("与其感慨路难行" "不如马上出发")
      ("不以物喜 不以己悲" "先天下之忧而忧 后天下之乐而乐")
      ("悟已往之不谏" "知来者之可追")
      ("抽象")
      ("未来从今天开始" "而不是明天")
      ("革命的道路" "同世界上一切事物活动的道路一样" "总是曲折 不是笔直的")
      ("老骥伏枥 志在千里" "烈士暮年 壮心不已")
      ("不要消极" "要积极出击")
      ("世上无难事" "只怕有心人")
      ("存地失人 人地皆失" "存人失地 人地皆存")
      ("往者不可追" "来者犹可待")
      ("胜兵先胜而后求战" "败兵先战而后求胜")
      ("胜可知而不可为")
      ("等死，死国可乎")
      ("冰冻三尺 非一日之寒")))

  (defvar my/mottoes
    (let (ret)
      (dolist (raw-motto my/raw-mottoes ret)
        (setq ret (cons (my/process-raw-mottoes raw-motto) ret)))))

  (setq initial-scratch-message
        (concat ";; Hello, " user-full-name "\n"
                (nth (random (length my/mottoes))
                     my/mottoes)
                "\n"))
#+end_src

* OS-Specific Settings

** Windows

*** powershell

Since I mostly use Emacs on Windows platform, I need this package to
interact nicely with the OS. Emacs built-in eshell mode and term mode
does not work properly on Windows. This package also comes with a
powershell mode to help editing powershell script files.

#+begin_src emacs-lisp
  (use-package powershell :defer t)
#+end_src

*** Find :DEPENDENCY:

Windows provides a find program which accepts different arguments than
the Linux one. Emacs works out-of-the-box with Linux find program, so
on Windows I have to tell Emacs where the find program, which accepts
Linux find program conventional arugments, is.

#+begin_src emacs-lisp
  (if (eq system-type 'windows-nt)
      (setq find-program "C:/msys64/usr/bin/find.exe"))
#+end_src

*** Hide Dos EOL

When working on Windows, sometimes I encounter files containing mixed
EOL characters. This would make some lines ended with additional
=^M=. To hide these anoyying characters, I use the following function.

#+begin_src emacs-lisp
  (defun remove-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))
#+end_src

*** Alert & Notifications

On Linux, Emacs could use D-BUS to send desktop
notifications. However, I could not make dbus work on Windows, so I
found this alert-toast package to implement this feature.

#+begin_src emacs-lisp
  (if (eq system-type 'windows-nt)
      (use-package
        alert-toast
        :after alert
        :config
        (setq alert-default-style 'toast)))
#+end_src

* Utiliy Packages

** ripgrep

ripgrep is a multi-threaded version of grep. It is quite useful when
searching for certain text.

#+begin_src emacs-lisp
  (use-package ripgrep :defer t)
#+end_src

** ace-window

By default, to switch between windows, you have to use the built in
command =other-window=. This would iterate through all displayed windows
and make one of them active a time. When there are more than two
windows displayed, this process becomes daunting. ace-windows makes
this process easier by allowing use specify which window should become
the next active window directly.

#+begin_src emacs-lisp
  (use-package ace-window
               :defer t
               :config
               (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
               :bind
               (([remap other-window] . ace-window)
                ("C-c w s" . ace-swap-window)))
#+end_src

** wgrep

wgrep allows users to modify grep/ripgrep outputs and save the changes
to each output's original location. It is a really powerful
interactive text file editing tool.

#+begin_src emacs-lisp
  (use-package wgrep :defer t)
#+end_src

** zoom

By default, when multiple windows are displayed, Emacs split the
screen evenly among them. However, sometimes, this not what I
like. For example, when I am editing one buffer while reading the
content of another buffer, I may want to make the edited buffer takes
up most of the screen space. Emacs has a serie of built-in commands
such as =enlarge-window= which allow users to adjust the window size as
they want. However, this process is repetitive and boring, because it
usually only enlarge/shrink the window by one row/column. zoom helps
me conveniently change the ration of windows sizes by simply execute
one single command.

#+begin_src emacs-lisp
  (use-package zoom
               :defer t
               :config
               (setq zoom-size '(0.618 . 0.618))
               :bind
               ("C-c z" . zoom)
               ("C-c Z" . zoom-mode))
#+end_src

** scratch

This program allows user to create a scratch buffer of a certain mode,
so you can write anything in it.

#+begin_src emacs-lisp
  (use-package scratch
    :defer t
    :bind
    ("C-c s c" . scratch))
#+end_src

** Pomodoro and Timers

Sometimes I use the [[https://en.wikipedia.org/wiki/Pomodoro_Technique][pomodoro technique]] to force myself focus on my
task. I have tried [[https://github.com/SqrtMinusOne/pomm.el][pomm]] but I do not like its behavior. It
automatically switch to the next state, while I want to do this
manually. Then I found [[https://github.com/TatriX/pomidor/][pomidor]], this is exactly what I wanted.

Sometimes I just want to set a timer, and I found [[https://github.com/protesilaos/tmr][tmr]]. It's simple and
easy to use.

#+begin_src emacs-lisp
  ;; (use-package pomm
  ;;              :defer t
  ;;              :config
  ;;              (pomm-mode-line-mode)
  ;;              (setq pomm-work-period 30
  ;;                    pomm-short-break-period 10)
  ;;              :bind
  ;;              ("C-c t p" . pomm)
  ;;              ("C-c t 3" . pomm-third-time))

  (use-package tmr
    :defer t
    :bind
    (("C-c t T" . tmr)
     ("C-c t t" . tmr-with-description)
     ("C-c t r" . tmr-remove-finished)
     ("C-c t R" . tmr-remove)
     ("C-c t l" . tmr-tabulated-view)))

  (use-package pomidor
    :defer t
    :bind (("C-c t p" . pomidor))
    :config
    (setq
     pomidor-sound-tick nil
     pomidor-sound-tack nil
     pomidor-seconds (* 30 60)
     pomidor-break-seconds (* 10 60)
     pomidor-long-break-seconds (* 25 60)
     pomidor-alert (lambda ()
                     (let ((message (pomidor-default-alert-message)))
                       (when message
                         (alert message :title "Pomidor"))))))
#+end_src

* Programming

** linum-mode

linum-mode displays line number on the side of the buffer, which is a
good visual hint when programming. It helps you locate warning and
error information generated by the compiler. It is also useful when
working with version control tools or communicating with other
programmers.

#+begin_src emacs-lisp
  (defvar my-linum-inhibit-modes
    '(eshell-mode
      shell-mode
      dired-mode
      help-mode
      text-mode
      fundamental-mode
      compilation-mode
      woman-mode
      Info-mode
      calc-mode
      calc-trail-mode
      org-mode
      vc-git-log-edit-mode
      log-edit-mode
      term-mode
      speedbar-mode
      gnus-summary-mode
      gnus-article-mode
      calendar-mode)
    "Major modes without line number.")

  (defun display-line-numbers-mode-hook-setup ()
    (setq display-line-numbers (not (memq major-mode my-linum-inhibit-modes))))

  (add-hook 'display-line-numbers-mode-hook 'display-line-numbers-mode-hook-setup)

  (global-display-line-numbers-mode)
#+end_src

** Templates or Snippets

When programming, we have to write some boilerplate code: the
structure of the piece of code is conventional, we only need to
replace some key text in it, for example, the name of the variable.

There is a well-known package for this task: yasnippet. However, this
package is not maintained actively for more than two years (today is
2022-12-10, and its last commit time is 2020-06-04). Thus, I switch to
another package, tempel. Though it is a new package, it has its own
advantages. First, it relies on Emacs built-in Tempo library. Second,
its simple enough to learn and work with. Third, it is maintained
actively. However, since yasnippet is well-known, some other packages,
such as lsp-mode, depends on it somehow, so I still install it.

#+begin_src emacs-lisp
  (use-package
   tempel
   :defer t
   :init
   ;; Setup completion at point
   (defun tempel-setup-capf ()
     ;; Add the Tempel Capf to `completion-at-point-functions'.
     ;; `tempel-expand' only triggers on exact matches. Alternatively use
     ;; `tempel-complete' if you want to see all matches, but then you
     ;; should also configure `tempel-trigger-prefix', such that Tempel
     ;; does not trigger too often when you don't expect it. NOTE: We add
     ;; `tempel-expand' *before* the main programming mode Capf, such
     ;; that it will be tried first.
     (setq-local completion-at-point-functions
                 (cons #'tempel-expand
                       completion-at-point-functions)))
   :bind
   (("M-+" . tempel-insert)
    ("M-*" . tempel-complete))
   :hook
   ((prog-mode . tempel-setup-capf)
    (text-mode . tempel-setup-capf)))

  (use-package
   yasnippet
   :diminish
   :defer t
   :hook
   (prog-mode . yas-minor-mode)
   :bind
   ("C-c Y" . yas-reload-all))
#+end_src

** Completion

Completion is an important feature of modern IDE. With the help of
language server protocol, Emacs could also provide such service to
programmers.

*** corfu

corfu is a completion front end package. That is, it is responsible to
display the completion condidates on the screen.

#+begin_src emacs-lisp
  (use-package
   corfu
   :init
   (setq corfu-auto nil
         corfu-cycle t
         corfu-quit-at-boundary nil
         corfu-quit-no-match nil
         corfu-preview-current nil
         corfu-excluded-modes '(gud-mode))
   ;; disalbe corfu in gud-mode, see
   ;; https://github.com/minad/corfu/issues/157 for more detail
   (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (corfu-mode 1)))
   :hook
   (minibuffer-setup . corfu-enable-in-minibuffer)
   :bind
   (:map corfu-map
         ("C-n" . corfu-next)
         ("C-p" . corfu-previous)
         ("<tab>" . corfu-next)
         ("S-<tab>" . corfu-previous)
         ("C-g" . corfu-quit)
         ("<escape>" . corfu-quit)
         ("SPC" . corfu-insert-separator))
   )

  (unless (display-graphic-p)
    (progn
      (use-package corfu-terminal :defer t)
      (corfu-terminal-mode +1)))

  (global-corfu-mode)
#+end_src

*** cape

cape provides a set of completion backends. A compeltion back ends
decides what are the completion condidates.

#+begin_src emacs-lisp
  (use-package company :defer t)
  (use-package
   cape
   :defer t
   :config
   (add-to-list 'completion-at-point-functions #'cape-dabbrev)
   (add-to-list 'completion-at-point-functions #'cape-file)
   (require 'company-clang)
   (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-clang)))
#+end_src

** General Settings

#+begin_src emacs-lisp
  (defun prog-mode-setup ()
    (display-fill-column-indicator-mode t)
    (setq show-trailing-whitespace t)
    (electric-pair-mode t)
    (hs-minor-mode 1)
    (hl-line-mode 1))
  (add-hook 'prog-mode-hook 'prog-mode-setup)
#+end_src

** Code Formatting :DEPENDENCY:

If the code keeps a consistent and easy-to-read format, it will be
much easier to read and maintain. However, manually formatting the
code cannot assure consistency and is also a boring process. We can
use our time to think about more valuable problems. Thus, using a nice
code formatting tool is necessary.

#+begin_src emacs-lisp
  (use-package clang-format :defer t)
  (use-package inheritenv :defer t)
  (use-package language-id :defer t)
  (use-package format-all :defer t)
#+end_src

** flycheck

flycheck is an error checking package, which displays inline visual
hint for possible code warnning or error. Currently, I only use it as
a facility for lsp.

#+begin_src emacs-lisp
  (use-package flycheck :defer t :diminish)
#+end_src

** hl-todo

This package highlighs certain keywords in comments and string literals.

#+begin_src emacs-lisp
  (use-package
   hl-todo
   :defer t
   :config
   (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO" warning bold)
          ("FIXME" error bold)
          ("HACK" font-lock-constant-face bold)
          ("REVIEW" font-lock-keyword-face bold)
          ("NOTE" success bold)
          ("DEPRECATED" font-lock-doc-face bold)
          ("BUG" error bold)))
   :hook (prog-mode . hl-todo-mode))
#+end_src

** git-gutter :DEPENDENCY:

This packages add visual hint on the fringe to indicate which part of
the file is added/deleted/modified agianst the latest version in the
version control system.

#+begin_src emacs-lisp
  (use-package
   git-gutter
   :diminish
   :defer t
   :config
   (setq git-gutter:handled-backends '(git svn))
   :hook
   (prog-mode . git-gutter-mode)
   :bind
   ("C-c G" . git-gutter))
#+end_src

** Documentation Style

Emacs 28 supports syntax highlighting for documentations in comments.

#+begin_src emacs-lisp
  (setq-default c-doc-comment-style
                '((java-mode . javadoc)
                  (pike-mode . autodoc)
                  (c-mode    . doxygen)
                  (c++-mode  . doxygen)))
#+end_src

** evil-nerd-commenter

Commenting a piece of code might be one of the most frequent
operations a programmer performs. Thus, we need a convenient and smart
package to help us perform this task. evil-nerd-commenter fits my
need.

#+begin_src emacs-lisp
  (use-package
   evil-nerd-commenter
   :defer t
   :bind
   (("C-c c" . evilnc-comment-or-uncomment-lines)
    ("C-c C" . evilnc-copy-and-comment-lines)))
#+end_src

** Symbol Highlighting

When inspecting a piece of code, I need to highlight some of the
symbols to help me quickly locate the places they are referenced.
symbol-overlay is the best package I have knonw for this task.

#+begin_src emacs-lisp
  (use-package
   symbol-overlay
   :defer t
   :bind
   (("C-c s p" . symbol-overlay-put)
    ("C-c s r" . symbol-overlay-remove-all))
   :config
   (setq symbol-overlay-inhibit-map t))
#+end_src

** lsp :DEPENDENCY:

Language server protocol is a powerful tool. It enables Eamcs provide
IDE-like functions, such as auto-completion,
jump-to-definition/declaraction, find-references and even
variable-rename.

#+begin_src emacs-lisp
  (use-package
   lsp-mode
   :defer t
   :init
   (defun corfu-lsp-setup ()
     (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
           '(orderless))
     (advice-add #'lsp-completion-at-point :around #'cape-wrap-noninterruptible))
   :config
   (setq lsp-headerline-breadcrumb-enable nil
         lsp-semantic-tokens-apply-modifiers nil
         lsp-semantic-tokens-enable t)
   (if (and (package-installed-p 'corfu) (package-installed-p 'cape))
       (progn
         (add-hook 'lsp-completion-mode-hook #'corfu-lsp-setup)
         (setq lsp-completion-provider :none)))
   :hook
   (lua-mode . (lambda () (setq-local lsp-enable-indentation nil)))
   :bind
   (("C-c l l" . lsp)
    :map lsp-mode-map
    ("C-c l c" . lsp-find-declaration)
    ("C-c l f" . lsp-find-definition)
    ("C-c l o" . lsp-clangd-find-other-file)
    ("C-c l r" . lsp-workspace-restart)
    ("C-c l d" . lsp-workspace-shutdown)
    ("C-c l a" . lsp-execute-code-action)
    ("C-c l n" . lsp-rename)
    ("C-c l t" . lsp-semantic-tokens-mode)))

  (use-package
   lsp-ui
   :defer t
   :bind
   (:map lsp-ui-mode-map
         ("C-c l g" . lsp-ui-doc-glance)
         ("C-c l F" . lsp-ui-doc-focus-frame))
   :config
   (setq lsp-ui-doc-show-with-mouse nil))

  (use-package
   consult-lsp
   :after (lsp-mode consult)
   :bind
   (:map lsp-mode-map
         ("C-c l S" . consult-lsp-symbols)
         ("C-c l s" . consult-lsp-file-symbols)
         ("C-c l i" . consult-lsp-diagnostics)))

  (with-eval-after-load 'lsp-clangd
    (setq lsp-clients-clangd-args
          '("--completion-style=detailed"
            "--header-insertion=never"
            "--function-arg-placeholders=0"
            "-j=32"
            "--background-index"
            "--pch-storage=memory")))

  (add-to-list 'safe-local-eval-forms '(lsp))
#+end_src

** Syntax Highlighting :DEPRECATED:

Eamcs has built-in syntax highlighting support, however it is based on
regular expression. This means it would not be correct in every
situation.

lsp also provides syntax highlighting support. This requires a backend
server, and sometimes it is too heavy to practice. What if we are
editing a simple one-file program but still want better syntax
highlighing?

I find the package tree-sitter. Its solution is better than regular
expression but still not a full functional compiler. This means it is
better than the built-in syntax highlighting solution but still not
totally correct. However, it is light-weight enough, so it is still a
viable choice.

After Emacs 29, tree-sitter has been integrated into Emacs core. There
is no need to install these additional packages anymore. Instead,
Emacs need to be compiled with tree-sitter library. Also, users have
to compile language specific shared library themselves to support
specific langauge major mode.

#+begin_src emacs-lisp :tangle no
  (use-package
   tree-sitter
   :diminish
   :defer t
   :hook
   ((c-mode . tree-sitter-mode)
    (c++-mode . tree-sitter-mode)
    (lua-mode . tree-sitter-mode)
    (tree-sitter-after-on . tree-sitter-hl-mode)))

  (use-package
   tree-sitter-langs
   :defer t)
#+end_src

** Programming Languages

*** C++

#+begin_src emacs-lisp
  (defun my/c-indent-then-complete ()
    (interactive)
    (if (= 0 (c-indent-line-or-region))
        (completion-at-point)))
  (with-eval-after-load 'cc-mode
    (define-key c++-mode-map [remap c-indent-line-or-region] 'my/c-indent-then-complete))
#+end_src

*** Lua

#+begin_src emacs-lisp
  (use-package lua-mode :defer t)
#+end_src

*** Scheme

Scheme is a dialect of Lisp. It is also the language used in the
famous book /Structure and Interpretation of Computer Programs/. Emacs
provide nice support for scheme language. It has a built-in package
scheme-mode. The command ~run-scheme~ starts an inferior scheme process
inside Emacs. After that, you can evaluate scheme expression in any
scheme-mode buffer. The expression is evaluated in the inferior scheme
process.

**** Use Scheme in org-mode

To execute scheme code in org-mode, org-babel's [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-scheme.html][document]] requires
[[https://www.nongnu.org/geiser/][Geiser]].

#+begin_src emacs-lisp
  (use-package geiser :defer t)
#+end_src

Geiser is an Emacs front end of a Scheme interpreter, and it supports
multiple implementations.

***** A Minor Issue

I was using org 9.5 and I found org-babel failed to execute scheme
code in org-mode buffer. After a simple serach, I found one who had
encountered the same
issue. https://www.mail-archive.com/emacs-orgmode@gnu.org/msg142485.html

It turns out there is a bug in org and I have to upgrade it to version
9.6 to fix it.

**** Scheme Implementations

***** Chicken

The first scheme implementation I used is the [[https://call-cc.org/][chicken
compiler]]. According to its [[https://wiki.call-cc.org/emacs#builtin-scheme-support][documents]], to use it with Emacs built-in
support is easy.

#+begin_src emacs-lisp :tangle no
  (setq scheme-program-name "csi -:c")
#+end_src

However, it needs some additional setup to work with org-babel (see
its [[https://wiki.call-cc.org/emacs#geiser][documents]]). What's more, it does not support Windows platform
nicely. First, there is no pre-built binaries or installers. Though
MSYS2-MinGW 64 package manager could install a package, it is acutally
not viable. I have to build the compiler myself. Second,
=chicken-install=, which is a prerequisite for it to work with
org-babel, cannot work correctly on Windows. Chicken requires users to
apply for an account to report bug, which is not convenient.

***** Chez :DEPENDENCY:

After I have found that I cannot make chicken work with org-babel on
Windows, I switch to [[https://github.com/cisco/ChezScheme][Chez]]. It has nice Windows support, i.e. a Windows
installer. It also host a repository on github so it is easy to report
a bug. Finally, it does not require additional setup to work with
Emacs. The only thing I have to do is to expose its binary =scheme= in
the =PATH=.

#+begin_src emacs-lisp
  (use-package geiser-chez :defer t)
#+end_src

*** Graphviz Dot

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode :defer t)
#+end_src

** Unreal :DEPENDENCY:

I am working with Unreal Engine, using Emacs + clang + lsp-mode as my
editing environment. I still have to use Visual Studio to build the
project, so Emacs is not my whole development environment.

*** Generating Compilation Database

Since clang + lsp-mode requires a compilation database to work, I need
to generate one for my Unreal project. Unreal has complex building
process, it has its own building tool. Unreal Build Tool (UBT)
provides a mode which can be used to generate the compilation
database. I write the following code to ease this process.

#+begin_src emacs-lisp
  (defvar my/ubt-location nil "File location of Unreal Build Tool")

  ;; TODO: Parameterize platform and configuration.
  (defun my/ubt-generate-clang-database (project-path)
    "Genertae compilation database for specified Unreal project."
    (interactive "fProject path: ")
    (let ((project-name (file-name-base project-path)))
      (async-shell-command (concat
                            my/ubt-location
                            " -mode=GenerateClangDatabase "
                            project-path
                            " "
                            project-name
                            "Editor Development Win64"))))
#+end_src

*** Generate Header Files

Unreal Header Tool is a program which scans user code and generate
code to implement its reflection system. Its methodology is to use
some macros which expands to file name and line number. Then it
generates code which substitues those macros. As a result, once the
macro's location has changed, the file will fail the
compilation. However, changing of line number is frequent. This makes
clang fail to compile the code, thus providing less useful information
when editing. The solution is to generate code every time some macro's
line number has changed.

#+begin_src emacs-lisp
  ;; TODO: Parameterize platform and configuration.
  (defun my/ubt-generate-header-file (project-path)
    "Generate header files for specified Unreal project."
    (interactive "fProject path: ")
    (let ((project-name (file-name-base project-path)))
      (async-shell-command (concat my/ubt-location
                                   " -SkipBuild "
                                   project-path
                                   " "
                                   project-name
                                   "Editor Development Win64"))))
#+end_src

* org-mode

#+begin_src emacs-lisp
  (use-package org
    :defer t
    :config
    (setq org-ellipsis "⤵"
          org-auto-align-tags nil
          org-tags-column 0
          org-catch-invisible-edits 'show-and-error
          org-special-ctrl-a/e t
          org-insert-heading-respect-content t
          org-hide-emphasis-markers t
          org-pretty-entities t
          org-babel-C-compiler "clang"
          org-babel-C++-compiler "clang++")
    (add-to-list 'org-babel-load-languages '(C . t))
    (add-to-list 'org-babel-load-languages '(scheme . t))
    (add-to-list 'org-babel-load-languages '(dot . t))
    (add-to-list 'org-modules 'org-habit t)
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))

  (use-package htmlize :defer t)
#+end_src

** Appearance =org-modern=

org-modern is a package that beautify org-mode. It changes the
appearance of header line, table, time stamp and other things.

#+begin_src emacs-lisp
  (use-package org-modern
               :defer t
               :hook (org-mode . global-org-modern-mode))
#+end_src

** Exporting Chinese Paragraph to HTML

Due to the difference between English and Chinese, there are some
extra spaces in exported Chinese paragraph when exporting to
HTML. These spaces are necessary since English uses spaces to separate
words, but Chinese don't. We have to override this behavior.

#+begin_src emacs-lisp
  (defadvice org-html-paragraph (before org-html-paragraph-advice
                                        (paragraph contents info) activate)
    "Join consecutive Chinese lines into a single long line without
     unwanted space when exporting org-mode to html."
    (let* ((origin-contents (ad-get-arg 1))
           (fix-regexp "[[:multibyte:]]")
           (fixed-contents
            (replace-regexp-in-string
             (concat
              "\\(" fix-regexp "\\) *\n *\\(" fix-regexp "\\)") "\\1\\2" origin-contents)))
      (ad-set-arg 1 fixed-contents)))
#+end_src

** Markups across More Lines

org-mode has built-in support for inline emphasis markups. By default,
these markups only works when the content inside only contain one
newline character. To make it works with more newlines in it, use the
following code:

#+begin_src emacs-lisp
  (use-package org
               :defer t
               :config
               (setcar (nthcdr 4 org-emphasis-regexp-components) 5)
               (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))
#+end_src

** Show org-agenda Buffer at Start-up

#+begin_src emacs-lisp
  (defun my/get-org-agenda-buffer ()
    (org-agenda-list)
    (get-buffer "*Org Agenda*"))
  (setq initial-buffer-choice #'my/get-org-agenda-buffer)
#+end_src

** capture

#+begin_src emacs-lisp
  (use-package org
               :defer t
               :config
               (setq org-default-notes-file (concat org-directory "/notes.org")))
#+end_src

* Citation

Currently I am using org-cite, citar plus citeproc to deal with
citation issues.

** citar

#+begin_src emacs-lisp
  (use-package citar
    :defer t
    :init
    (setq org-cite-global-bibliography '("~/org-roam/references.bib")
          org-cite-insert-processor 'citar
          org-cite-follow-processor 'citar
          org-cite-activate-processor 'citar
          citar-bibliography org-cite-global-bibliography
          org-cite-export-processors '((t . (csl "modern-language-association.csl"))))
    :hook
    (org-mode . citar-capf-setup))

  (use-package citar-embark
    :defer t
    :after (citar embark)
    ;; :no-require
    :diminish
    :config (citar-embark-mode))

  ;; You can get the csl style files from
  ;; https://github.com/citation-style-language/styles

  ;; (setq org-cite-csl-styles-dir "path/to/styles/dir")
#+end_src

Also, =org-cite-csl-styles-dir= must be set for the csl styles to work.

** citar-org-roam

A necessary package to integrate citar with org-roam, thus,
bibliographic notes can be easily created in org-roam context.

#+begin_src emacs-lisp
  (use-package citar-org-roam
    :diminish
    :after (citar org-roam)
    ;; :no-require
    :config
    (citar-org-roam-mode)
    (setq citar-org-roam-subdir "references"))
#+end_src

* Taking Notes

As a text editor, Emacs is a good place to take notes. There are also
packages helps you orgnize your notes. The most popular one is
org-roam. A lighter-weight choice is denote. These two packages are
often used to practice a note-taking methodology called [[https://zettelkasten.de/introduction/][Zettelkasten]].

** org-roam

#+begin_src emacs-lisp
  (use-package org-roam
    :defer t
    :init
    (setq
     org-roam-directory "~/org-roam/"
     org-roam-node-display-template (concat "${title} " (propertize "${tags}" 'face 'org-tag))
     org-roam-capture-templates '(("d" "default" plain "%?" :target
                                   (file+head "%<%Y%m%d%H%M%S>.org" "#+title: ${title}\n")
                                   :unnarrowed t)
                                  ("p" "private" plain "%?" :target
                                   (file+head "private/%<%Y%m%d%H%M%S>.org.gpg" "#+title: ${title}\n")
                                   :unnarrowed t)
                                  ("r" "reference" plain "%?" :target
                                   (file+head "references/%<%Y%m%d%H%M%S>.org" "#+title: ${title}\n")
                                   :unnarrowed t))
     org-roam-dailies-capture-templates '(("d" "default" entry "* %?" :target
                                           (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))
                                          ("p" "private" entry "* %?" :target
                                           (file+head "%<%Y-%m-%d>.org.gpg" "#+title: %<%Y-%m-%d>\n"))))
    :config
    (org-roam-db-autosync-mode)
    :bind
    (("C-c n f" . org-roam-node-find)
     ("C-c n i" . org-roam-node-insert)
     ("C-c n c" . org-roam-capture)
     ("C-c n d" . org-roam-dailies-goto-today)
     ("C-c n D" . org-roam-dailies-goto-date)
     ("C-c n t" . org-roam-tag-add)
     ("C-c n T" . org-roam-tag-remove)
     ("C-c n r" . org-roam-ref-add)
     ("C-c n R" . org-roam-ref-remove)
     ("C-c n b" . org-roam-buffer-toggle)
     ("C-c n B" . org-roam-buffer)
     ("C-c n a" . org-roam-alias-add)
     ("C-c n A" . org-roam-alias-remove)))

  (use-package org-roam-ui :defer t)
#+end_src

** consult-org-roam

Utility package makes org-roam using consult to search notes, forward
and backward links. It improves the workflow and thus efficiency.

#+begin_src emacs-lisp
  (use-package consult-org-roam
     :after (org-roam consult)
     :diminish
     :init
     (require 'consult-org-roam)
     ;; Activate the minor mode
     (consult-org-roam-mode 1)
     :custom
     ;; Use `ripgrep' for searching with `consult-org-roam-search'
     (consult-org-roam-grep-func #'consult-ripgrep)
     ;; Configure a custom narrow key for `consult-buffer'
     (consult-org-roam-buffer-narrow-key ?r)
     ;; Display org-roam buffers right after non-org-roam buffers
     ;; in consult-buffer (and not down at the bottom)
     ;; (consult-org-roam-buffer-after-buffers t)
     :config
     ;; Eventually suppress previewing for certain functions
     ;; (consult-customize
     ;;  consult-org-roam-forward-links
     ;;  :preview-key (kbd "M-."))
     :bind
     ;; Define some convenient keybindings as an addition
     ("C-c n f" . consult-org-roam-file-find)
     ("C-c n l" . consult-org-roam-backlinks)
     ("C-c n L" . consult-org-roam-forward-links)
     ("C-c n s" . consult-org-roam-search))
#+end_src

** denote

#+begin_src emacs-lisp :tangle no
  (use-package denote
               :defer t
               :config
               (setq denote-directory "~/note"
                     denote-known-keywords '("emacs")
                     denote-prompts '(title keywords)
                     denote-backlinks-show-context t)
               :bind
               (("C-c n d" . denote-open-or-create)
                ("C-c n l" . denote-link-or-create)
                ("C-c n B" . denote-link-backlinks)
                ("C-c n b" . denote-link-find-backlink)
                ("C-c n o" . denote-link-find-file)
                ("C-c n M" . denote-rename-file)
                ("C-c n m" . denote-rename-file-using-front-matter)
                ("C-c n j" . my-denote-journal)
                ("C-c n a" . denote-keywords-add)
                ("C-c n r" . denote-keywords-remove)))

  (defun my-denote--journal-today-file ()
    "Find today's _journal entry, else return nil."
     (seq-find
      (lambda (file)
        (string-match-p (format "%s.*_journal" (format-time-string "%A-%e-%B-%Y")) file))
      (denote-directory-files)))

  (defun my-denote--create-journal ()
      "Create an entry tagged 'journal'."
      (interactive)
      (denote (format-time-string "%A %e %B %Y")
              '("journal")))

  (defun my-denote-journal ()
    "Open or create journal for today."
    (interactive)
    (let ((prompt (my-denote--journal-today-file)))
      (if prompt
          (funcall-interactively 'denote-open-or-create prompt)
        (my-denote-create-journal))))
#+end_src

* Completion

** vertico

Emacs has a tons of variables, commands and documents. When you
exploring them, vertico provides a much more informative interface for
you to browse those information.

#+begin_src emacs-lisp
  (use-package vertico
    :demand t
    :config
    (setq read-extended-command-predicate #'command-completion-default-include-p
          enable-recursive-minibuffers t))
  (vertico-mode)
#+end_src

** orderless

orderless allows the completion systems using a different completion
strategy. The default completion systems complets based on prefix
matching. orderless enable it to use a fuzzy matching strategy. This
is quite useful because you do not always remember exactly what you
want to search. Sometimes, you do not even know if the things in your
head exist or not, but you want to use the completions system as a
tool to verify your assumption. Orderless completion is really helpful
in these situations.

#+begin_src emacs-lisp
  (use-package orderless
    :demand t
    :config
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** marginalia

Marginalia works together with vertico, it provides more information
of a variable or function in the completion interface. This may help
you locate your target more quickly.

#+begin_src emacs-lisp
  (use-package marginalia :defer t)
  (marginalia-mode)
#+end_src

** consult

consult works together with vertico. It helps you complete among lots
of things, such as buffers, file contents, grep results, find results,
etc..

#+begin_src emacs-lisp
  (use-package
    consult
    :init
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    (defun consult-ripgrep-with-prefix ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-ripgrep)))
    :config
    (setq consult-fontify-max-size 262144) ;; 262144 = 2 ^ 18

    (defvar consult--fd-command nil)
    (defun consult--fd-builder (input)
      (unless consult--fd-command
        (setq consult--fd-command
              (if (eq 0 (call-process-shell-command "fdfind"))
                  "fdfind"
                "fd")))
      (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                   (`(,re . ,hl) (funcall consult--regexp-compiler
                                          arg 'extended t)))
        (when re
          (cons (append
                 (list consult--fd-command
                       "--color=never" "--full-path"
                       (consult--join-regexps re 'extended))
                 opts)
                hl))))

    (defun consult-fd (&optional dir initial)
    (interactive "P")
    (pcase-let* ((`(,prompt ,paths ,dir) (consult--directory-prompt "Fd" dir))
                 (default-directory dir))
      (find-file (consult--find prompt #'consult--fd-builder initial))))

    ;; this handles problems when consult results contains
    ;; Chinese characters
    (if (eq system-type 'windows-nt)
        (progn
          ;; https://github.com/minad/consult/issues/572
          (add-to-list 'process-coding-system-alist
                       '("[rR][gG]" . (utf-8 . gbk-dos)))
          ;; https://github.com/minad/consult/issues/601
          (setq consult-find-args (concat find-program " . "))))
    :bind
    (([remap switch-to-buffer] . consult-buffer)
     ("C-c i" . consult-line)
     ("C-c r" . consult-ripgrep-with-prefix)
     ("C-c R" . consult-ripgrep)
     ("C-c I" . consult-imenu)
     ("C-c f" . consult-fd)
     ("C-c H" . consult-org-heading))
    :demand t
    )
#+end_src

** embark

embark allows users perform certain tasks in the completion
interface. This reduces the number of operations users have to
perform. For example, when you are trying to delete a certain file,
you have to =find-file= to open the directory the file is located. Then
mark the file to be deleted in dired and finally execute the delete
operation. With embark, you can simply browse to the file in
completion system and then execute =embark-act= then use its delete file
function to delete the current completion condidate. Much more
convenient.

#+begin_src emacs-lisp
  (use-package embark
               :defer t
               :bind ("<f5>" . embark-act))
  (use-package embark-consult :defer t)
#+end_src

* Project Management

Project can be applied to orgnize anything you are working on. Not
only programming project, but also writing project, note-taking
project, etc.. projectile helps you browse project files, search
contents in project and even run and test project (if it is a
programming project).

#+begin_src emacs-lisp
  (use-package
   projectile
   :diminish
   :defer t
   :bind
   (("C-c p f" . projectile-find-file)
    ("C-c p i" . projectile-invalidate-cache)
    ("C-c p s" . projectile-switch-project)
    ("C-c p d" . projectile-dired)
    ("C-c p r" . projectile-ripgrep))
   :config
   (projectile-global-mode))
#+end_src

* Version Control

** magit :DEPENDENCY:

magit is the well-known Emacs interface for git.

#+begin_src emacs-lisp
  (use-package
   magit
   :defer t
   :bind
   ("C-c M" . magit))
#+end_src

** vc-svn

#+begin_src emacs-lisp
  (setq vc-svn-annotate-switches "-x --ignore-eol-style")
#+end_src

* nXML Mode

By default, nXML mode does not support hide and show certain blocks
(sections/nodes), this piece of code add this feature using hs-minor
mode.

Credit: https://stackoverflow.com/questions/944614/emacs-does-hideshow-work-with-xml-mode-sgml-mode

#+begin_src emacs-lisp
  (add-to-list 'hs-special-modes-alist
               (list 'nxml-mode
                     "<!--\\|<[^/>]*[^/]>"
                     "-->\\|</[^/>]*[^/]>"
                     "<!--"
                     'nxml-forward-element
                     nil))

  (add-hook 'nxml-mode-hook 'hs-minor-mode)
#+end_src

* Mail in Emacs

I still can't get Gnus work, but the config I copied from this [[https://news.ycombinator.com/item?id=23420308][thread]]
does work. I'll paste them here for future reference.

#+begin_src emacs-lisp :tangle no
  (setq
   user-full-name "Chang Xiaoduan"
   user-mail-address "drcxd@sina.com"
   send-mail-function 'smtpmail-send-it
   smtpmail-smtp-server "smtp.sina.com"
   smtpmail-stream-type 'starttls
   smtpmail-smtp-service 587
   gnus-select-method
   '(nnimap "sina"
            (nnimap-address "imap.sina.com")
            (nnimap-server-port 993)
            (nnimap-stream ssl)
            (nnmail-expiry-wait immediate)))
#+end_src

The config I figured out by reading the manual myself is like this:

#+begin_src emacs-lisp
  (setq
   gnus-select-method '(nnimap "imap.sina.com")
   send-mail-function 'smtpmail-send-it
   smtpmail-smtp-server "smtp.sina.com"
   smtpmail-stream-type 'starttls
   smtpmail-servers-requiring-authorization "sina")
#+end_src

The second variable is necessary. Otherwise, I got an
"smtpmail-send-it: Sending failed: 530 Authentication required".
According to smtpmail.el, it should try again when the server is
requesting authentication. However, it does not. By setting the
varaible ~smtpmail-servers-requiring-authorization~, smtpmail would ask
for authentification by default.

* Key Binding

** Native Command Key Bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c E") 'eval-region)
  (global-set-key (kbd "C-c P") 'compile)
  (global-set-key (kbd "C-c b") 'switch-to-buffer)
  (global-set-key (kbd "C-c o") 'other-window)
  (global-set-key (kbd "C-c k") 'kill-buffer)
  (global-set-key (kbd "C-c S") 'shell-command)
  (global-set-key (kbd "C-c w 1") 'delete-other-windows)
  (global-set-key (kbd "C-c w 2") 'split-window-vertically)
  (global-set-key (kbd "C-c w 3") 'split-window-horizontally)
  (global-set-key (kbd "C-c w 0") 'delete-window)
  (global-set-key (kbd "C-c s t") 'hs-toggle-hiding)
  (global-set-key (kbd "C-c s f") 'flyspell-mode)
  (global-set-key (kbd "C-c s b") 'flyspell-buffer)
  (global-set-key (kbd "C-c w m") 'woman)
  (global-set-key (kbd "C-<tab>") 'completion-at-point)
#+end_src

** meow

meow is a modal editing package. It looks like evil, but I think it
suits Emacs more than evil. meow provides supports for many Emacs
packages native key bindings, such as org-mode. For example, when
using meow, you can execute the command =org-babel-tangle= by pressing
=SPC c v t= out-of-the-box, while its original key binding is =C-c C-v
t=. It also works well with my own native key bindings. When using
meow, I do not have to change my original key binding settings. I only
add some additional configuration specific to meow.

#+begin_src emacs-lisp
  (use-package
   meow
   :demand t
   :init
   (defun meow-setup ()
     (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
     (meow-motion-overwrite-define-key
      ;; '("j" . meow-next)
      ;; '("k" . meow-prev)
      '("<escape>" . ignore))
     (meow-leader-define-key
      ;; SPC j/k will run the original command in MOTION state.
      ;; '("j" . "H-j")
      ;; '("k" . "H-k")
      ;; Use SPC (0-9) for digit arguments.
      '("1" . meow-digit-argument)
      '("2" . meow-digit-argument)
      '("3" . meow-digit-argument)
      '("4" . meow-digit-argument)
      '("5" . meow-digit-argument)
      '("6" . meow-digit-argument)
      '("7" . meow-digit-argument)
      '("8" . meow-digit-argument)
      '("9" . meow-digit-argument)
      '("0" . meow-digit-argument)
      '("/" . meow-keypad-describe-key)
      '("?" . meow-cheatsheet))
     (meow-normal-define-key
      '("0" . meow-expand-0)
      '("9" . meow-expand-9)
      '("8" . meow-expand-8)
      '("7" . meow-expand-7)
      '("6" . meow-expand-6)
      '("5" . meow-expand-5)
      '("4" . meow-expand-4)
      '("3" . meow-expand-3)
      '("2" . meow-expand-2)
      '("1" . meow-expand-1)
      '("-" . negative-argument)
      '(";" . meow-reverse)
      '("," . meow-inner-of-thing)
      '("." . meow-bounds-of-thing)
      '("[" . meow-beginning-of-thing)
      '("]" . meow-end-of-thing)
      '("a" . meow-append)
      '("A" . meow-open-below)
      '("b" . meow-back-word)
      '("B" . meow-back-symbol)
      '("c" . meow-change)
      '("d" . meow-delete)
      '("D" . meow-backward-delete)
      '("e" . meow-next-word)
      '("E" . meow-next-symbol)
      '("f" . meow-find)
      '("g" . meow-cancel-selection)
      '("G" . meow-grab)
      '("h" . meow-left)
      '("H" . meow-left-expand)
      '("i" . meow-insert)
      '("I" . meow-open-above)
      '("j" . meow-next)
      '("J" . meow-next-expand)
      '("k" . meow-prev)
      '("K" . meow-prev-expand)
      '("l" . meow-right)
      '("L" . meow-right-expand)
      '("m" . meow-join)
      '("M" . magit)
      '("n" . meow-search)
      '("o" . meow-block)
      '("O" . meow-to-block)
      '("p" . meow-yank)
      '("P" . meow-yank-pop)
      ;; '("q" . meow-quit)
      ;; '("Q" . meow-goto-line)
      '("q" . evilnc-comment-or-uncomment-lines)
      '("Q" . evilnc-copy-and-comment-lines)
      '("r" . meow-replace)
      '("R" . meow-swap-grab)
      '("s" . meow-kill)
      '("S" . shell-command)
      '("t" . meow-till)
      '("u" . meow-undo)
      '("U" . meow-undo-in-selection)
      '("v" . meow-visit)
      '("w" . meow-mark-word)
      '("W" . meow-mark-symbol)
      '("x" . meow-line)
      '("X" . meow-goto-line)
      '("y" . meow-save)
      '("Y" . meow-sync-grab)
      '("z" . meow-pop-selection)
      '("'" . repeat)
      '("<escape>" . ignore)
      '("=" . indent-region)
      '("`" . delete-horizontal-space)
      '("{" . backward-paragraph)
      '("}" . forward-paragraph)
      '("/" . hs-toggle-hiding)))
   :config
   (setq meow-replace-state-name-list
        '((normal . "[N]")
          (motion . "[M]")
          (keypad . "[K]")
          (insert . "[I]")
          (beacon . "[B]")))
   (setq meow-keypad-leader-dispatch "C-c")
   (setq meow-mode-state-list
         '((special-mode . motion)
           (text-mode . normal)))
   (meow-setup)
   (meow-global-mode 1)
   (global-set-key (kbd "<f6>") 'meow-keypad))
#+end_src

*** A Note About KEYPAD Mode

Meow's default behavior is to add =C-`= prefix to any key with no
prefix. This looks counter-intuitive to me. Meow is trying to simulate
Emacs native key bindings, but this behavior is the contrary of Emacs
native style. For example, command =view-echo-area-message= is bound to
=C-h e=, and command =view-external-packages= is bound to =C-h
C-e=. Translated into Meow, =view-echo-area-message= is bound to =SPC h
SPC e=, while =view-external-packages= is bound to =SPC h
e=. =view-external-packages= has more key strokes in native key bindings,
but has less key stokes in Meow. =view-echo-area-message= has less key
strokes in native key bindings, but has more key strokes in Meow.

Also, Meow has a fallback mechanism. Meow maps =C-h k= to =SPC h SPC k=,
and =C-h C-k= to =SPC h k=. However, when =C-h C-k= is unbound, =SPC h k= will
automatically invokes the command bound to =C-h k=. This is convenient,
but it introduces uncertenty. Meow users could not know the command
=SPC h k= invokes is bound to which native key binding: =C-h C-k= or =C-h
k=.

The author's explanation for this behavior is [[https://github.com/meow-edit/meow/issues/47#issuecomment-1377206836][here]]. I try to
understand and accept the author's idea, but I still found that if
KEYPAD does not automatically add =C-= prefix would be better. I have
asked the author to add an option to let users make their own choices,
but the author seems not agree with me.

Thus, I tried to dig into the source code and modify them by
myself. In =meow-keypad.el=, there is a function
=meow-keypad-self-insert=, which defines how KEYPAD translate key
strokes. If we exchange the code dealing with literal and non-prefix
cases, then we change KEYPAD's behavior to not automatically add =C-=
prefix, but only when =SPC= is pressed. This modification introduces a
new problem: which-key prompt for KEYPAD key bindings does not update
to fit this change. There are two additional functions
=meow--keypad-format-keys= and =meow--keypad-get-keymap-for-describe=, they all
have similar structures to that of =meow-keypad-self-insert=, deal with
them so that Meow generate the correct hints.

** which-key

With so many key bindings, it is impossible to memorize all of
them. which-key is a package that displays all viable commands and
their key bindings when you are in the middle of a sequence of key
binding.

#+begin_src emacs-lisp
  (use-package
   which-key
   :diminish
   :config
   (which-key-mode))
#+end_src

* Load Custom File

Finally, after all the other settings have been done, we load the
local customization file.

#+begin_src emacs-lisp
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src
